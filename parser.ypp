%{
	#include "attributes.h"
	#include <iostream>
	#include <stdlib.h>

	using namespace std;

	extern int yylex();		// do they both need to be extern?
    int yyerror(char * message);
	scopes* scopesList;
%}

%token B
%token BYTE BOOL INT VOID TRUE FALSE RETURN WHILE BREAK SC COMMA ID NUM STRING
%right IF
%nonassoc RPAREN
%nonassoc ELSE
%right ASSIGN
%nonassoc RELOP
%left EQ_OP
%left OR
%left AND
%left PLUS_MINUS
%left MUL_DIV
%left NOT
%left LBRACE LBRACK LPAREN RBRACE RBRACK

%%

Program	:	Funcs
    	;

Funcs :
		|	Function Funcs
		;
Function : FunctionDefinition LBRACE_t Statements RBRACE_t
        ;


FunctionDefinition : RetType ID LPAREN Formals RPAREN {scopesList->addFunction(*$1,*$2,*$4); scopesList->newFunctionScope(*$2);}
                   ;

RetType : Type          {$$ = $1;}      //Lior
		| VOID          {	Type tmp; $$ = new parsedData( Type(tmp.VOID));}    //Lior
		;

Formals	:	                    {$$ = new parsedData();}  //Lior
		|	FormalsList         {$$ = $1;}             //Lior
		;

Type_ID : Type ID       {$$ = new parsedData(*$1, *$2);}    //Lior
		;

FormalsList	:	FormalDecl FormalsList2        { $$ = new parsedData(*$1,*$2) ;}
			;

FormalsList2 :                          {parsedData temp; $$ = new parsedData(temp,IS_CALL); }
			 |	COMMA FormalsList       { $$ = new parsedData(*$2, IS_CALL); }
			 ;

FormalDecl :	Type_ID	FormalDecl2     { scopesList->addId(*$1,*$1,*$2);
                                         $$ = new parsedData(*$1, *$2);}     //Lior
			;

FormalDecl2	:
			| 	LBRACK NUM_T RBRACK     {$$ = new parsedData(*$2,IS_ARRAY);}         //Lior
			;

NUM_T :	NUM NUM_T2  {$$ = new parsedData(*$1, *$2); /*TODO add type/byte check */	}    //Lior
		;

NUM_T2 :                 {$$ = new parsedData(Type::INTEGER);}     //Lior
		| B              {$$ = new parsedData(Type::BYTE);}    //Lior
		;


Statements :    Statement     // done
			|   Statement Statements    // done
			;

Statement : 	LBRACE_t Statements RBRACE_t        // done
			|	Type_ID SC          {scopesList->addIdNotArray(*$1);}         // done
			|	Type_ID ASSIGN Exp SC           {scopesList->addIdNotArray(*$1); scopesList->verifyAssign(*$1,*$3);}     // done
			|	Type_ID LBRACK NUM_T RBRACK SC      {scopesList->addId(*$1,*$1,*$3);}      // done
			|	ID ASSIGN Exp SC        {scopesList->verifyAssign(*$1,*$3);}       // done
			|	ID LBRACK Exp RBRACK ASSIGN Exp SC  {scopesList->verifyAssignToArray(*$1,*$3,*$6);}         // done
			|	Call SC             // done
			|	RETURN SC           {scopesList->verifyReturnTypeVoid();}       // done
			|	RETURN Exp SC       {scopesList->verifyReturnType(*$2);}       // done
			|   IF LPAREN Exp RPAREN Open_Scope Statement { scopesList->removeScope(); }
			|   IF LPAREN Exp RPAREN Open_Scope Statement ELSE CloseScope Open_Scope Statement { scopesList->removeScope(); }
			|	While_Statement
			|	BREAK SC            {scopesList->verifyBreakBlock();}        // done
			|   SC
			;

Open_Scope : { scopesList->newRegularScope(false);}
           ;

CloseScope : { scopesList->removeScope(); }
           ;

While_Statement : While_Open Statement { scopesList->removeScope(); }          // done
            ;

While_Open : WHILE LPAREN Exp RPAREN {scopesList->verifyExpIsBool(*$3); scopesList->newRegularScope(true); }    // done
        ;

//end of need to fix if

//TODO Inbar call returns type
Call	:	ID LPAREN ExpList RPAREN    {scopesList->verifyFunctionCall(*$1,*$3);
                                         $$ = new parsedExp((scopesList->getFunction($1->getName())).return_type);}
		|	ID LPAREN RPAREN            {scopesList->verifyNoParametersFunctionCall(*$1);
		                                 $$ = new parsedExp((scopesList->getFunction($1->getName())).return_type);}
		;
//TODO Lior
ExpList:    Exp ExpList2 {  $$ = new parsedData(*$1,*$2) ;}

ExpList2 :                  { $$ = new parsedData(); }
         | COMMA ExpList    { $$ = new parsedData(*$2, IS_CALL); }
         ;

Type	:	INT              {	Type tmp; $$ = new parsedData(parsedData(Type(tmp.INTEGER)));} // to return new type with appropriate type
		|	BYTE             {	Type tmp; $$ = new parsedData(parsedData(Type(tmp.BYTE)));}
		| 	BOOL             {	Type tmp; $$ = new parsedData( parsedData(Type(tmp.BOOL)));}
		;

Exp		:	LPAREN Exp RPAREN       {$$ = $2;}
		| 	ID LBRACK Exp RBRACK    {if (scopesList->containsIdName($1->getName())){
		                                if ($3->isInteger()){
		                                    $$ = new parsedExp(scopesList->getId($1->getName()).type);
		                                }
		                                else
		                                    throw;  //TODO Exp not an inteeger!
                                    }
		                             else
		                                throw;      //TODO ID doesn't exist!
		                             }
		| 	Exp PLUS_MINUS Exp      {$$ = new parsedExp(*$1,*$3, MATH_OP);}
		|	Exp MUL_DIV Exp         {$$ = new parsedExp(*$1,*$3, MATH_OP);}
		| 	ID                      {if (scopesList->containsIdName($1->getName())){
		                                $$ = new parsedExp(scopesList->getId($1->getName()).type);
		                                }
		                            }
		|	Call                    {$$ = $1;}
		|	NUM_T	                {$$ = new parsedExp(*$1);}
		|	STRING                  {	Type tmp;
                                        $$ = new parsedExp(Type(tmp.STRING));} // return string type
		|	TRUE	                {	Type tmp; $$ = new parsedExp(Type(tmp.BOOL));} // return bool type
		|	FALSE	                {	Type tmp; $$ = new parsedExp(Type(tmp.BOOL));} // return bool type
		|	NOT Exp	                {$$ = new parsedExp(*$2, BOOL_OP);; }  // make sure Exp type is bool
		|	Exp OR Exp              {$$ = new parsedExp(*$1,*$3, BOOL_OP);}  // make sure Exp and Exp are of type bool
		|	Exp AND Exp	            {$$ = new parsedExp(*$1,*$3, BOOL_OP);}     // make sure Exp and Exp are of type bool
		|	Exp EQ_OP Exp           {$$ = new parsedExp(*$1,*$3, REL_OP);}     // For ambiguity reasons!!!!!!!!!
		|	Exp RELOP Exp           {$$ = new parsedExp(*$1,*$3, REL_OP);}       // make sure Exp and Exp are COMPATIABLE types
		;

LBRACE_t : LBRACE { scopesList->newRegularScope(false); }
         ;

RBRACE_t : RBRACE{ scopesList->removeScope(); }
         ;

%%

int main()
{
	// initSystem
	scopesList = new scopes();
	scopesList->scopesList.push_front( scope(0,false));
	Type tmp;
    scopesList->addInitialFunction( Type(tmp.VOID),string("print"), Type(tmp.STRING));
    scopesList->addInitialFunction( Type(tmp.VOID),string("printi"), Type(tmp.INTEGER));

	yyparse();
	delete scopesList;
}

int yyerror(char * message)
{
	cout << "Parse error: "<<message<<endl;
	exit(0);
}