%{
	#include "attributes.h"
	#include <iostream>
	#include <stdlib.h>

	using namespace std;

	extern int yylex();		// do they both need to be extern?
	extern int yyerror(char * message);

	scopes* scopesList;
%}

%token B
%token BYTE BOOL INT VOID TRUE FALSE RETURN WHILE BREAK SC COMMA ID NUM STRING
%right IF
%nonassoc RPAREN
%nonassoc ELSE
%right ASSIGN
%nonassoc RELOP
%left EQ_OP
%left OR
%left AND
%left PLUS_MINUS
%left MUL_DIV
%left NOT
%left LBRACE LBRACK LPAREN RBRACE RBRACK

%%

Program	:	Funcs
    	;

Funcs :
		|	Function Funcs
		;
Function : FunctionDefinition LBRACE_t Statements RBRACE_t
        ;


FunctionDefinition : RetType ID LPAREN Formals RPAREN {scopesList>addFunction($1,$2,$4); scopesList->newFunctionScope($2);}
                   ;

RetType : Type          {$$ = $1;}      //Lior
		| VOID          {$$ = new Type(VOID);}    //Lior
		;

Formals	:	                    {$$ = new parsedData}  //Lior
		|	FormalsList         {$$ = $1}             //Lior
		;

Type_ID : Type ID       {$$ = new parsedData($1, $2);}    //Lior
		;

FormalsList	:	FormalDecl FormalsList2         { /*$$ = { FormalDecl merge FormalsList2 } ;*/ }   //Lior
			;

FormalsList2 :       {/* $$ = {new empty list or retType}; */}    //Lior
			 |	COMMA FormalsList       {/* $$ = { merge FormalsList to $$} ;*/}    //Lior
			 ;

FormalDecl :	Type_ID	FormalDecl2     { addId($1,$1,$2);
                                            /*$$ = new retType list with one node contains the data of $! and $2 */}     //Lior
			;

FormalDecl2	:
			| 	LBRACK NUM_T RBRACK     {/*add information about array  */}         //Lior
			;

NUM_T :	NUM NUM_T2  {$$ = new parsedData($1, $2); /*TODO add type/byte check */	}    //Lior
		;

NUM_T2 :                 {$$ = new parsedData();}     //Lior
		| B              {$$ = new parsedData(Type(BYTE));}    //Lior
		;


Statements :    Statement     // done
			|   Statement Statements    // done
			;

Statement : 	LBRACE_t Statements RBRACE_t        // done
			|	Type_ID SC                          {scopesList->addIdNotArray($1)}         // done
			|	Type_ID ASSIGN Exp SC               {scopesList->addIdNotArray($1);
			                                         scopesList->verifyAssign($1,$3)}     // done
			|	Type_ID LBRACK NUM_T RBRACK SC      {scopesList->addId($1,$1,$3)}      // done
			|	ID ASSIGN Exp SC                    {scopesList->verifyAssign($1,$3)}       // done
			|	ID LBRACK Exp RBRACK ASSIGN Exp SC  {scopesList->verifyAssignToArray($1,$3,$6)}         // done
			|	Call SC             // done
			|	RETURN SC                           {scopesList->verifyReturnTypeVoid();}       // done
			|	RETURN Exp SC                       {scopesList->verifyReturnType($2);}       // done
			|   If_State
			|   IF LPAREN Exp RPAREN Statement
			|   IF LPAREN Exp RPAREN Statement ELSE Statement
			|	While_Statement
			|	BREAK SC                             {scopesList->verifyBreakBlock();}        // done
			|   SC
			;

If_State : If_Open If_Internal_Statement

If_Internal_Statement : Statement {scopesList->removeScope();}
                      ;

If_Open  : IF LPAREN Exp RPAREN { scopesList->newRegularScope(false);}
         ;



While_Statement : While_Open Statement { scopesList->removeScope(); }          // done
            ;

While_Open : WHILE LPAREN Exp RPAREN {scopesList->verifyExpIsBool($3); scopesList->newRegularScope(true); }    // done
        ;

//end of need to fix if

//TODO Inbar call returns type
Call	:	ID LPAREN ExpList RPAREN    {scopesList->verifyFunctionCall($1,$3);
                                         $$ = new parsedExp((scopesList->getFunction($1.getName())).type);}
		|	ID LPAREN RPAREN            {scopesList->verifyNoParametersFunctionCall($1);
		                                 $$ = new parsedExp((scopesList->getFunction($1.getName())).type);}
		;
//TODO Lior
ExpList:    Exp ExpList2 {  $$ = new parsedData($1,$2) ;}

ExpList2 :                  { $$ = new parsedData(); }
         | COMMA ExpList    { $$ = new parsedData($2, IS_CALL); }
         ;

Type	:	INT              {$$ = new Type(INT);} // to return new type with appropriate type
		|	BYTE             {$$ = new Type(BYTE);}
		| 	BOOL             {$$ = new Type(BOOL);}
		;

Exp		:	LPAREN Exp RPAREN       {$$ = $2;}
		| 	ID LBRACK Exp RBRACK    {if (scopesList->containsIdName($1.getName())){
		                                if ($3.isInteger())
		                                    return parsedExp(scopesList->getId($1.getName()).type);
		                                }
		                                else
		                                    throw;  //TODO Exp not an inteeger!

		                             else
		                                throw;      //TODO ID doesn't exist!
		                             }
		| 	Exp PLUS_MINUS Exp      {$$ = new parsedExp($1,$3, MATH_OP);}
		|	Exp MUL_DIV Exp         {$$ = new parsedExp($1,$3, MATH_OP);}
		| 	ID                      {if (scopesList->containsIdName($1.getName())){
		                                $$ = parsedExp(scopesList->getId($1.getName()).type);
		                                }
		                            }
		|	Call                    {$$ = $1;}
		|	NUM_T	                {$$ = new parsedExp($1);}
		|	STRING                  {$$ = new parsedExp(Type(STRING));} // return string type
		|	TRUE	                {$$ = new parsedExp(Type(BOOL));} // return bool type
		|	FALSE	                {$$ = new parsedExp(Type(BOOL));} // return bool type
		|	NOT Exp	                {$$ = new parsedExp($2, BOOL_OP);; }  // make sure Exp type is bool
		|	Exp OR Exp              {$$ = new parsedExp($1,$3, BOOL_OP);}  // make sure Exp and Exp are of type bool
		|	Exp AND Exp	            {$$ = new parsedExp($1,$3, BOOL_OP);}     // make sure Exp and Exp are of type bool
		|	Exp EQ_OP Exp           {$$ = new parsedExp($1,$3, REL_OP);}     // For ambiguity reasons!!!!!!!!!
		|	Exp RELOP Exp           {$$ = new parsedExp($1,$3, REL_OP);}       // make sure Exp and Exp are COMPATIABLE types
		;

LBRACE_t : LBRACE { scopesList->newRegularScope(false); }
         ;

RBRACE_t : RBRACE{ scopesList->removeScope(); }
         ;

%%

int main()
{
	// initSystem
	scopesList = new scopes();
	scopesList->push_front(new scope(0,false));

    addInitialFunction(new Type(Type.VOID),"print",new Type(Type.STRING));
    addInitialFunction(new Type(Type.VOID),"printi",new Type(Type.INTEGER));

	yyparse();
	delete scopesList;
}

int yyerror(char * message)
{
	cout<<"Parse error: "<<message<<endl;
	exit(0);
}