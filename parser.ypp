%{
	#include "attributes.h"
	#include <iostream>
	#include <stdlib.h>

	using namespace std;

	extern int yylex();		// do they both need to be extern?
	int yyerror(char * message);
%}


%token B
%token BYTE BOOL INT VOID TRUE FALSE RETURN IF ELSE WHILE BREAK SC COMMA ID NUM STRING
%right ASSIGN
%nonassoc RELOP
%left EQ_OP
%left OR
%left AND
%left PLUS_MINUS
%left MUL_DIV
%left NOT
%left LBRACE LBRACK LPAREN RBRACE RBRACK RPAREN

%%


Program	:	Funcs
    	;

Funcs 	:	
		|	RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE Funcs
		;
		
RetType : Type          {$$ = $1;}
		| VOID          {$$ = new parsedType(NOTHING);}
		;
		
Formals	:	
		|	FormalsList
		;
		
Type_ID : Type ID       {$$ = new parsedTpID($1, $2);}
		;
		
FormalsList	:	FormalDecl FormalsList2
			;

FormalsList2	:	
				|	COMMA FormalsList
				;

FormalDecl	:	Type_ID	FormalDecl2
			;

FormalDecl2	:	
			| 	LBRACK NUM_T RBRACK
			;

NUM_T	:	NUM NUM_T2  {$$ = new parsedNum($1, $2);	}
		;
		
NUM_T2	:               {$$ = new parsedNum();}
		| B             {$$ = new parsedNum(BYTE);}
		;

Statements : Statement
			| Statement Statements
			;

Statement	:	LBRACE Statements RBRACE
			|	Type_ID SC
			|	Type_ID ASSIGN Exp SC
			|	Type_ID LBRACK NUM_T RBRACK SC
			|	ID ASSIGN Exp SC
			|	ID LBRACK Exp RBRACK ASSIGN Exp SC
			|	Call SC
			|	RETURN SC
			|	RETURN Exp SC
			|	IF_STATE
			|	WHILE LPAREN Exp RPAREN Statement
			|	BREAK SC
			;
			
IF_STATE	:	IF LPAREN Exp RPAREN Statement IF_STATE_ELSE
			;

IF_STATE_ELSE	:	
				|	ELSE Statement
				;

Call	:	ID LPAREN ExpList RPAREN    {$$ = new parsedCall($1,$3);}
		|	ID LPAREN RPAREN            {$$ = new parsedCall($1);}
		;

ExpList	:	Exp                     {$$ = new parsedExpList($1)}
		|	Exp COMMA ExpList       {$$ = new parsedExpList($1, $2);}
		;
		
Type	:	INT              {$$ = new parsedType(INT);}
		|	BYTE             {$$ = new parsedType(BYTE);}
		| 	BOOL             {$$ = new parsedType(BOOL);}
		;
		
Exp		:	LPAREN Exp RPAREN       {$$ = $1;}
		| 	ID LBRACK Exp RBRACK    {$$ = new parsedExp($1,$3);}
		| 	Exp PLUS_MINUS Exp      {$$ = new parsedExp($1,parsedOp(yytext),$3);}
		|	Exp MUL_DIV Exp         {$$ = new parsedExp($1,parsedOp(yytext),$3);}
		| 	ID                      {$$ = new parsedExp($1);}
		|	Call                    {$$ = new parsedExp($1);}
		|	NUM_T	                {$$ = new parsedExp($1);}
		|	STRING                  {$$ = new parsedExp($1);}
		|	TRUE	                {$$ = new parsedExp(true);}
		|	FALSE	                {$$ = new parsedExp(false);}
		|	NOT Exp	                {$$ = new !$1; }
		|	Exp OR Exp              {$$ = new parsedExp($1,parsedOp('||'),$3);}
		|	Exp AND Exp	            {$$ = new parsedExp($1,parsedOp('&&'),$3);}
		|	Exp EQ_OP Exp           {$$ = new parsedExp($1,$parsedOp(yytext)2,$3);}
		|	Exp RELOP Exp           {$$ = new parsedExp($1,parsedOp(yytext),$3);}
		;

%%

int main()
{
	yyparse();
}

int yyerror(char * message)
{
	cout<<"Parse error: "<<message<<endl;
	exit(0);
}