%{
	#include "attributes.hpp"
	#include <iostream>
	#include <stdlib.h>

	using namespace std;
    extern int yylineno;
	extern int yylex();		// do they both need to be extern?
	extern CodeBuffer buffer;
	extern scopes* scopesList;
	extern vector<int> goToMainBackPatch;
    void yyerror(const char * message);

    #define TRY_AND_CATCH(statement_to_try)                             \
        try{                                                            \
            (statement_to_try);                                         \
        }catch(parsingExceptions& e){                                   \
             throw parsingExceptions(e.err_type, yylineno, e.id);       \
        }

    #define PRINT_HW3_STUFF 0
    #define PRINT_HW5_STUFF 1

    #define EMIT_TEXT(string) buffer.emit(string)
    #define EMIT_DATA(string) buffer.emitData(string)
    #define EXC static_cast<parsedExp*>
    #define STC static_cast<parsedStatement*>

    #define CODE_COMMENT(str) if(0) buffer.emit(static_cast<string>("# ") + static_cast<string>(str))
%}

%token B
%token BYTE BOOL INT VOID TRUE FALSE RETURN WHILE BREAK SC COMMA ID NUM STRING
%right IF
%right ASSIGN
%left OR
%left AND
%left EQ_OP
%nonassoc RELOP
%left PLUS_MINUS
%left MUL_DIV
%right NOT
%left LPAREN
%left RPAREN
%nonassoc ELSE
%left LBRACE LBRACK RBRACE RBRACK

%%

Program	:	Funcs
    	;

Funcs :
		|	Function Funcs
		;
Function : FunctionDefinition LBRACE Gen_Label Statements RBRACE_t {
                                                                    scopesList->functions.front().beginLabel = STC$3->beginLabel;
                                                                    if($1->single_var.name == "main"){
                                                                        buffer.bpatch(goToMainBackPatch,STC$3->beginLabel);
                                                                    }
                                                                    buffer.emit(string("# End of function"));

                                                                    delete $1; delete $3; delete $4;}
        ;

FunctionDefinition : RetType ID LPAREN Formals RPAREN {TRY_AND_CATCH(scopesList->addFunction(*$1,*$2,*$4));
                                                       TRY_AND_CATCH(scopesList->newFunctionScope(*$4));
                                                       $$ = $2;
                                                       buffer.emit(string("# Function: ") + $2->single_var.name);
                                                       //if($2->single_var.name == "main")
                                                        //buffer.emit(string("main:"));

                                                       delete $1; delete $4;}
                   ;

RetType : Type          {$$ = $1;}
        | VOID          {$$ = new parsedData(Type(Type::VOID));}
        ;

Formals	:	                    {$$ = new parsedData();}  //Lior
		|	FormalsList         {$$ = $1;}
		;

Type_ID : Type ID       {if(scopesList->containsIdName($2->getName()))
                            throw parsingExceptions(parsingExceptions::ERR_DEF, yylineno, $2->getName());

                         $$ = new parsedData($1->single_var.type, $2->single_var.name);
                         delete $1; delete $2;
                        }    //Lior
		;

FormalsList :   FormalDecl {$$ = new parsedData(*$1, IS_CALL);
                            delete $1;
                           }
            |   FormalDecl COMMA FormalsList {$$ = new parsedData(*$1,*$3) ;
                                              delete $1; delete $3;
                                             }
            ;

FormalDecl  :   Type_ID                     {TRY_AND_CATCH($$ = new parsedData(*$1));
                                             delete $1;
                                            }
            |   Type_ID LBRACK NUM_T RBRACK {TRY_AND_CATCH($$ = new parsedData(*$1, *$3, IS_ARRAY));
                                             delete $1; delete $3;
                                            }
            ;

NUM_T :	NUM NUM_T2  {try{$$ = new parsedData($2->single_var.type, $1->single_var.value);delete $1; delete $2;}
                     catch(parsingExceptions& e){throw parsingExceptions(e.err_type, yylineno, e.id);}}
		;

NUM_T2 :                {$$ = new parsedData(Type(Type::INTEGER));}     //Lior
       | B              {$$ = new parsedData(Type(Type::BYTE));}    //Lior
       ;


Statements  :   Statement {$$ = $1;}
            |   Statement Statements {
                                      $$ = new parsedStatement();
                                      STC$$->breakList = mergeVectors(STC$1->breakList,STC$2->breakList);
                                      delete $1; delete $2;
                                     }
            ;

Statement : 	LBRACE_t Statements RBRACE_t {$$ = $2;}
			|	Type_ID SC          {TRY_AND_CATCH(scopesList->addIdNotArray(*$1));
                                     $$ = new parsedStatement();

                                     string s1 = "subu $sp, $sp, ";
                                     string s2 = num_to_string(scopesList->getId($1->getName()).type.size()*4);
                                     EMIT_TEXT(s1 + s2);

                                     string s4 = "sw ";
                                     if($1->single_var.type.kind == Type::BOOL)
                                        s4 += codeGenerator::falseValueRepresentation();
                                     else
                                        s4 += string("$0");
                                     s4 += string(", 0($sp)");
                                     EMIT_TEXT(s4);

			                         delete $1;
			                         }
			|	Type_ID ASSIGN Exp SC           {TRY_AND_CATCH(scopesList->addIdNotArray(*$1));
			                                     TRY_AND_CATCH(scopesList->verifyAssign(*$1,*$3));
			                                     $$ = new parsedStatement();

			                                     string s1 = "subu $sp, $sp, ";
                                                 string s2 = num_to_string(scopesList->getId($1->getName()).type.size()*4);
                                                 EMIT_TEXT(s1 + s2);

                                                 string s4 = "sw ";
                                                 if($1->single_var.type.kind == Type::BOOL)
                                                    s4 += codeGenerator::falseValueRepresentation();
                                                 else
                                                    s4 += string("$0");
                                                 s4 += string(", 0($sp)");
                                                 EMIT_TEXT(s4);

			                                     codeGenerator::assignValueToId(scopesList->getId($1->getName()),*EXC$3);

                                                 if(!EXC$3->isBoolExp()) regFree(EXC$3->reg);

						                          delete $1; delete $3;
						                         }
			|	Type_ID LBRACK NUM_T RBRACK SC      {TRY_AND_CATCH(scopesList->addIdArray(*$1,*$1,*$3));
			                                         $$ = new parsedStatement();

                                                     string s1 = "subu $sp, $sp, ";
                                                     string var_offset = num_to_string(scopesList->getId($1->getName()).type.size()*4);

                                                     EMIT_TEXT(s1 + var_offset);

                                                     for(int i=0; i < $3->single_var.value ; i++){
                                                        regClass tempReg = regAlloc();
                                                        EMIT_TEXT(string("add ") + tempReg.toString() + string(", $sp, ") + num_to_string(i*4));
                                                        string s2 = string("sw ");
                                                        if($1->single_var.type.kind == Type::BOOL)
                                                           s2 += codeGenerator::falseValueRepresentation();
                                                        else
                                                           s2 += string("$0");
                                                        s2 += string(", (");
                                                        s2 += tempReg.toString();
                                                        s2 += string(")");
                                                        EMIT_TEXT(s2);

                                                        regFree(tempReg);
                                                    }

			                                         delete $1; delete $3;
			                                        }
			|	ID ASSIGN Exp SC        {if (!scopesList->containsIdName($1->getName()))
			                                throw parsingExceptions(parsingExceptions::ERR_UNDEF,yylineno, $1->getName() );
                                         TRY_AND_CATCH(scopesList->verifyAssign(*$1,*$3));

                                         $$ = new parsedStatement();
                                         codeGenerator::assignValueToId(scopesList->getId($1->getName()),*EXC$3);

                                         if(!EXC$3->isBoolExp()) regFree(EXC$3->reg);
                                         delete $1; delete $3;
                                        }
			|	ID LBRACK Exp RBRACK ASSIGN Exp SC  {if (!scopesList->containsIdName($1->getName()))
			                                            throw parsingExceptions(parsingExceptions::ERR_UNDEF,yylineno, $1->getName());
                                                     TRY_AND_CATCH(scopesList->verifyAssignToArray(*$1,*$3,*$6));

                                                     $$ = new parsedStatement();
                                                     codeGenerator::assignValueToArray(scopesList->getId($1->getName()),*EXC$3,*EXC$6);

                                                     delete $1; delete $3; delete $6;
                                                    }
			|	Call SC             {$$ = new parsedStatement();
			                        // code for calling is implemented in Call
			                        delete $1;
			                        }
			|	RETURN SC           {TRY_AND_CATCH(scopesList->verifyReturnTypeVoid());
			                        $$ = new parsedStatement(); // so delete later will be possible

			                        codeGenerator::returnVoidFunction();

			                        }
			|	RETURN Exp SC       {TRY_AND_CATCH(scopesList->verifyReturnType(*$2));
					                 $$ = new parsedStatement(); // so delete later will be possible

                                    codeGenerator::returnFunction(*EXC$2);

					                 delete $2;
					                }

           	|	While_Statement     {$$ = $1;}
			|	BREAK SC            {TRY_AND_CATCH(scopesList->verifyBreakBlock());
			                         $$ = new parsedStatement();
			                         STC$$->breakList.push_back(EMIT_TEXT("j "));
			                        }

			| If_Begin If_Continue {
                                    $$ = new parsedStatement();

                                    STC$$->breakList = STC$2->breakList;
                                    buffer.bpatch(STC$1->trueList, STC$2->ifTrueLabel);
                                    buffer.bpatch(STC$1->falseList, STC$2->ifFalseLabel);

                                    delete $1; delete $2;
                                   }
			;

If_Begin    :  IF LPAREN Exp {if(!$3->isBool()) throw parsingExceptions(parsingExceptions::ERR_MISMATCH,yylineno);
                              $$ = new parsedStatement(*(STC$3));
                              delete $3;
                             }
            ;

If_Continue :   RPAREN Open_Scope_and_create_label Statement {scopesList->removeScope();

                $$ = new parsedStatement();
                STC$$->breakList = STC$3->breakList;
                STC$$->ifTrueLabel = STC$2->beginLabel;
                STC$$->ifFalseLabel = buffer.genLabel();

                delete $2; delete $3; // second delete might be dangerous
            }
            |   RPAREN Open_Scope_and_create_label Statement ELSE Go_To_End_of_If_Statement CloseScope Open_Scope Gen_Label Statement {scopesList->removeScope();

                $$ = new parsedStatement();

                STC$$->breakList = mergeVectors(STC$3->breakList,STC$9->breakList);

                string endLabel = buffer.genLabel();
                buffer.bpatch(STC$5->nextList,endLabel);
                STC$$->ifTrueLabel = STC$2->beginLabel;
                STC$$->ifFalseLabel = STC$8->beginLabel;

                delete $2; delete $3; delete $5; delete $8; delete $9;
            }
            ;

Go_To_End_of_If_Statement : {
                             $$ = new parsedStatement();
                             STC$$->nextList.push_back(EMIT_TEXT("j "));
                            }

Gen_Label : {$$ = new parsedStatement(buffer.genLabel());}
Open_Scope : { scopesList->newRegularScope(false);}
           ;

Open_Scope_and_create_label:{
                             scopesList->newRegularScope(false);
                             $$ = new parsedStatement(buffer.genLabel());
                             }
           ;
CloseScope : { scopesList->removeScope(); }
           ;

While_Statement : While_Open Gen_Label Statement {scopesList->removeScope();
                                        $$ = new parsedStatement(); // for the delete at higher levels

                                        buffer.bpatch(STC$1->trueList, STC$2->beginLabel);

                                        string s1 = "j ";
                                        string s2 = STC$2->beginLabel;
                                        EMIT_TEXT(s1 + s2);

                                        string endLabel = buffer.genLabel();

                                        //cout << " in while statement, break list size is : " << STC$3->breakList.size() << endl ;
                                        buffer.bpatch(STC$3->breakList,endLabel);
                                        buffer.bpatch(STC$1->falseList,endLabel);

                                        delete $1; delete $2;
                                       }
            ;

While_Open : WHILE LPAREN Exp RPAREN {TRY_AND_CATCH(scopesList->verifyExpIsBool(*$3));
                                      TRY_AND_CATCH(scopesList->newRegularScope(true));

                                      $$ = new parsedStatement();
                                      STC$$->trueList = EXC$3->trueList;
                                      STC$$->falseList = EXC$3->falseList;
                                      delete $3;}
        ;

//TODO Inbar call returns type
Call	:	ID LPAREN ExpList RPAREN    {try {scopesList->verifyFunctionCall(*$1,*$3);}
                                            catch(parsingExceptions& e){
                                            if(e.err_type == parsingExceptions::ERR_PROTOTYPE_MISMATCH)
                                                throw parsingExceptions(e.err_type,
                                                yylineno, $1->getName(),scopes::listToVector(scopesList->getFunction($1->getName()).inputTypes));
                                            else
                                                throw parsingExceptions(e.err_type,
                                                yylineno, $1->getName());
                                            }

                                         $$ = new parsedExp((scopesList->getFunction($1->getName())).return_type);

                                         EXC$$->reg = regAlloc();
                                         if((scopesList->getFunction($1->getName())).return_type.kind == Type::VOID)
                                            EXC$$->regType = REG_TYPE_UNDEF;
                                         else
                                            EXC$$->regType = REG_TYPE_VALUE;

                                         codeGenerator::callFunction(scopesList->getFunction($1->getName()).beginLabel
                                                                      ,*EXC$3,EXC$$->reg);

                                         if(EXC$$->regType == REG_TYPE_UNDEF)
                                            regFree(EXC$$->reg);
                                         delete $1; delete $3;}
		|	ID LPAREN RPAREN            {try {scopesList->verifyNoParametersFunctionCall(*$1);
		                                    }catch(parsingExceptions& e){
		                                        if(e.err_type == parsingExceptions::ERR_PROTOTYPE_MISMATCH)
                                                    throw parsingExceptions(e.err_type,
                                                    yylineno, $1->getName(), scopes::listToVector(scopesList->getFunction($1->getName()).inputTypes));
                                                else throw parsingExceptions(e.err_type,yylineno, $1->getName());
                                        }
		                                 $$ = new parsedExp((scopesList->getFunction($1->getName())).return_type);

                                         EXC$$->reg = regAlloc();
                                         if((scopesList->getFunction($1->getName())).return_type.kind == Type::VOID)
                                            EXC$$->regType = REG_TYPE_UNDEF;
                                         else
                                            EXC$$->regType = REG_TYPE_VALUE;

                                         parsedExp dummy(Type::UNDEF);
                                         codeGenerator::callFunction(scopesList->getFunction($1->getName()).beginLabel,dummy,EXC$$->reg);

                                         if(EXC$$->regType == REG_TYPE_UNDEF)
                                            regFree(EXC$$->reg);

		                                 delete $1;}
		;

ExpList:    Exp ExpList2 {  $$ = new parsedExp(*EXC$1,*EXC$2) ;
                            $$->list_of_vars.front().reg = EXC$1->reg;
                            $$->list_of_vars.front().regType = EXC$1->regType;
                            $$->list_of_vars.front().trueList = EXC$1->trueList;
		                    $$->list_of_vars.front().falseList = EXC$1->falseList;
		                    delete $1; delete $2;}

ExpList2 :                  { $$ = new parsedExp(IS_CALL); }
         | COMMA ExpList    { $$ = $2;}
         ;

Type	:	INT              {$$ = new parsedData(Type(Type::INTEGER));}
		|	BYTE             {$$ = new parsedData(Type(Type::BYTE));}
		| 	BOOL             {$$ = new parsedData(Type(Type::BOOL));}
		;

Exp		:	LPAREN Exp RPAREN       {$$ = $2;}
		| 	ID LBRACK Exp RBRACK    {if (!scopesList->containsIdName($1->getName()))  //ID doesn't exist
                                        throw parsingExceptions(parsingExceptions::ERR_UNDEF,yylineno, $1->getName());
                                     if(!(scopesList->getId($1->getName()).type.kind == Type::ARRAY)) //ID is not an array
                                        throw parsingExceptions(parsingExceptions::ERR_MISMATCH,yylineno);
                                     if (!($3->isInteger())) // Exp is not a numeric type
                                        throw parsingExceptions(parsingExceptions::ERR_INVALID_ARRAY_SIZE, yylineno, $1->getName());

                                     $$ = new parsedExp(scopesList->getId($1->getName()).type.arrayType);

                                     EXC$$->reg = regAlloc();
                                     EXC$$->regType = REG_TYPE_VALUE;

                                     regClass addressReg = regAlloc();

                                     codeGenerator::generateArrayOverflowCheck(scopesList->getId($1->getName()).type.arrayLength,EXC$3->reg);
                                     codeGenerator::generateArrayLocationCalc(addressReg,EXC$3->reg,codeGenerator::idLocation(scopesList->getId($1->getName())));

                                     string location = string("(") + addressReg.toString() + string(")");

                                     string s1 = "lw ";
                                     string s2 = EXC$$->reg.toString();
                                     string s3 = ", ";
                                     string s4 = location;

                                     EMIT_TEXT(s1 + s2 + s3 + s4);

                                     regFree(addressReg);
                                     regFree(EXC$3->reg);
                                     delete $1; delete $3;
		                            }
		| 	Exp PLUS_MINUS Exp      {TRY_AND_CATCH($$ = new parsedExp(*$1,*$3, MATH_OP));
		                             EXC$$->reg = regAlloc();
                                     EXC$$->regType = REG_TYPE_VALUE;

                                     string s1 = codeGenerator::arithmeticOpToString($2->pd_op);
                                     string s2 = EXC$$->reg.toString();  //destination
                                     string s3 = ", ";
                                     string s4 = EXC$1->reg.toString();
                                     string s5 = ", ";
                                     string s6 = EXC$3->reg.toString();

                                     EMIT_TEXT(s1 + s2 + s3 + s4 + s5 + s6);
                                     if($$->single_var.type.kind == Type::BYTE){
                                        EMIT_TEXT(codeGenerator::byteArithmeticMasking(EXC$$->reg));
                                     }
                                     delete $1; delete $3;
                                     }
		|	Exp MUL_DIV Exp         {TRY_AND_CATCH($$ = new parsedExp(*$1,*$3, MATH_OP));
		                             EXC$$->reg = regAlloc();
		                             EXC$$->regType = REG_TYPE_VALUE;

		                             string s1 = codeGenerator::arithmeticOpToString($2->pd_op);

		                             if(s1 == "div "){
		                                EMIT_TEXT(codeGenerator::divisionByZeroCheck(EXC$3->reg));
		                             }

		                             string s2 = EXC$$->reg.toString();  //destination
		                             string s3 = ", ";
                                     string s4 = EXC$1->reg.toString();
                                     string s5 = ", ";
                                     string s6 = EXC$3->reg.toString();

                                     EMIT_TEXT(s1 + s2 + s3 + s4 + s5 + s6);
                                     if($$->single_var.type.kind == Type::BYTE){
                                        EMIT_TEXT(codeGenerator::byteArithmeticMasking(EXC$$->reg));
                                     }

                                     regFree(EXC$1->reg);
                                     regFree(EXC$3->reg);
                                     delete $1; delete $3;
                                     }
		| 	ID                      {if (!scopesList->containsIdName($1->getName()))
		                                throw parsingExceptions(parsingExceptions::ERR_UNDEF,yylineno, $1->getName());

		                             $$ = new parsedExp(scopesList->getId($1->getName()).type);
		                             EXC$$->reg = regAlloc();
                                     regClass addressReg = regAlloc();

                                     string s1 = string("add ") + addressReg.toString() + string(", $fp, ");
                                     s1 += codeGenerator::idOffsetFromFp(scopesList->getId($1->getName()));
                                     EMIT_TEXT(s1);

                                     if($$->kind == parsedData::DK_ARRAY){
                                        EXC$$->regType = REG_TYPE_REFERENCE;
                                        s1 = string("add ") + EXC$$->reg.toString() + string(", $0, ") + addressReg.toString();
                                     }
                                     else{
                                        EXC$$->regType = REG_TYPE_VALUE;
                                        s1 = string("lw ") + EXC$$->reg.toString() + string(", (") + addressReg.toString() + string(")");
                                     }
                                     EMIT_TEXT(s1);

                                     // case that id is boolean, then creates true/false lists for use of upstream code
                                     if(scopesList->getId($1->getName()).type.kind == Type::BOOL){
                                        regClass boolTrueValue = regAlloc();
                                        s1 = string("add ") + boolTrueValue.toString() + string(", $0, ");
                                        s1 += codeGenerator::trueValueRepresentation();
                                        EMIT_TEXT(s1);

                                        s1 = string("be ") + EXC$$->reg.toString() + string(", ") + boolTrueValue.toString() + string(", ");
                                        EXC$$->trueList.push_back(buffer.emit(s1));
                                        EXC$$->falseList.push_back(buffer.emit(string("j ")));

                                        regFree(EXC$$->reg);
                                        EXC$$->regType = REG_TYPE_UNDEF; // hope this is enough for representing null
                                        regFree(boolTrueValue);
                                     }

                                     regFree(addressReg);
                                     delete $1;
		                            }

		|	Call                    {$$ = $1;}

        |	NUM_T	                {$$ = new parsedExp(*$1);
                                    EXC$$->reg =  regAlloc();
                                    EXC$$->regType = REG_TYPE_VALUE;
                                    string s1 = "li "; // load immediate
                                    string s2 = EXC$$->reg.toString();
                                    string s3 = ", ";
                                    string s4 = num_to_string($$->single_var.value);
                                    EMIT_TEXT(s1 + s2 + s3 + s4);
                                    }

        |	STRING                  {$$ = new parsedExp(Type(Type::STRING));    // return string type
                                     EXC$$->reg =  regAlloc();
                                     EXC$$->regType = REG_TYPE_REFERENCE;

                                     // create string in .data segment
                                     string stringLocation = codeGenerator::pushStringToDataBuffer(*$1);

                                     // generate code " la  $$->reg, <string location label>"
                                     string s1 = "la "; // load address, need to verify it works with labels
                                     string s2 = EXC$$->reg.toString();
                                     string s3 = ", ";
                                     string s4 = stringLocation;
                                     EMIT_TEXT(s1 + s2 + s3 + s4);
                                    }
        |	TRUE	                {$$ = new parsedExp(Type(Type::BOOL)); // return bool type
                                     EXC$$->trueList.push_back(EMIT_TEXT("j "));
                                    }

		|	FALSE	                {$$ = new parsedExp(Type(Type::BOOL)); // return bool type
		                             EXC$$->falseList.push_back(EMIT_TEXT("j "));
                                    }

		|	NOT Exp	                {TRY_AND_CATCH($$ = new parsedExp(*$2, BOOL_OP));
		 		                     EXC$$->trueList = EXC$2->falseList;
		 		                     EXC$$->falseList = EXC$2->trueList;
		 		                     delete $2;
		 		                    }
		|	Exp OR Gen_Label Exp              {TRY_AND_CATCH($$ = new parsedExp(*$1,*$4, BOOL_OP));
                                        if(PRINT_DEBUG)
        		                            cout << "parsed exp OR exp: "
        		                            << $1->getName() << " " << $3->getName()
        		                            << endl;

                                     buffer.bpatch(EXC$1->falseList,EXC$3->beginLabel);
                                     EXC$$->falseList = EXC$4->falseList;
                                     EXC$$->trueList = mergeVectors(EXC$4->trueList,EXC$1->trueList);

        		                     delete $1; delete $3;
                                    }  // make sure Exp and Exp are of type bool
		|	Exp AND Gen_Label Exp	            {TRY_AND_CATCH($$ = new parsedExp(*$1,*$4, BOOL_OP));
                                        if(PRINT_DEBUG)
        		                            cout << "parsed exp AND exp: "
        		                            << $1->getName() << " " << $3->getName()
        		                            << endl;

        		                     buffer.bpatch(EXC$1->trueList,EXC$3->beginLabel);
                                    EXC$$->trueList = EXC$4->trueList;
                                    EXC$$->falseList = mergeVectors(EXC$4->falseList,EXC$1->falseList);

        		                     delete $1; delete $3;
                                    }     // make sure Exp and Exp are of type bool
		|	Exp EQ_OP Exp           {TRY_AND_CATCH($$ = new parsedExp(*$1,*$3, REL_OP));
		                                if(PRINT_DEBUG)
		                                    cout << "parsed exp EQ_OP exp: "
		                                     << $1->getName() << " " << $3->getName()
		                                     << endl;

                                     string s1 = codeGenerator::opToBranchString($2->pd_op); // branch type
                                     string s2 = EXC$1->reg.toString();
                                     string s3 = ", ";
                                     string s4 = EXC$3->reg.toString();
                                     string s5 = ", ";
                                     EXC$$->trueList.push_back(EMIT_TEXT(s1 + s2 + s3 + s4 + s5));
                                     EXC$$->falseList.push_back(EMIT_TEXT("j "));

                                     regFree(EXC$1->reg);
                                     regFree(EXC$3->reg);
                                     delete $1; delete $3;
                                     }
		|	Exp RELOP Exp           {TRY_AND_CATCH($$ = new parsedExp(*$1,*$3, REL_OP));
		                                if(PRINT_DEBUG)
        		                             cout << "parsed exp RELOP exp: "
        		                             << $1->getName() << " " << $3->getName()
        		                             << endl;

		                             string s1 = codeGenerator::opToBranchString($2->pd_op); // branch type
                                     string s2 = EXC$1->reg.toString();
                                     string s3 = ", ";
                                     string s4 = EXC$3->reg.toString();
                                     string s5 = ", ";
                                     EXC$$->trueList.push_back(EMIT_TEXT(s1 + s2 + s3 + s4 + s5));
                                     EXC$$->falseList.push_back(EMIT_TEXT("j "));

                                     regFree(EXC$1->reg);
                                     regFree(EXC$3->reg);
		                             delete $1; delete $3;
		                            }
		;


LBRACE_t : LBRACE { scopesList->newRegularScope(false); }
         ;

RBRACE_t : RBRACE{ scopesList->removeScope(); }
         ;

%%

int main()
{
    // magic from stack overflow :) redirect cout somewhere so we can keep old printing code as is

    streambuf* oldCoutStreamBuf;
    ostringstream strCout;
    if(!PRINT_HW3_STUFF){
        oldCoutStreamBuf = cout.rdbuf();
        cout.rdbuf( strCout.rdbuf() );
    }

	// initSystem
	scopesList = new scopes();
	scopesList->scopesList.push_front(scope(0,false));
    scopesList->addInitialFunction( Type(Type::VOID),string("print"), Type(Type::STRING));
    scopesList->addInitialFunction( Type(Type::VOID),string("printi"), Type(Type::INTEGER));

    codeGenerator::initiateHW5();

    try{
	    yyparse();
	}catch(parsingExceptions& e){
	    scopesList->need_to_print = false;
	}
	catch(...){
	    scopesList->need_to_print = false;
        if(PRINT_DEBUG) cout << "Something wierd happened!!!" << endl;
	}
	if(scopesList->need_to_print){      //check valid main function in the scopelist
	    if(!scopesList->containsFunctionName("main")){
   	        scopesList->need_to_print = false;
            errorMainMissing();
    	}else{
    	    function main_func = scopesList->getFunction("main");
    	    if((main_func.return_type.kind != main_func.return_type.VOID ||
    	            !main_func.inputTypes.empty())){
                scopesList->need_to_print = false;
                errorMainMissing();
                if(PRINT_DEBUG) cout <<"in the if to check the main function" << endl;
            }
        }
    }

    delete scopesList;

    // Restore old cout.
    if(!PRINT_HW3_STUFF) cout.rdbuf( oldCoutStreamBuf );
    if(PRINT_HW5_STUFF){
	    buffer.printCodeBuffer();
	    buffer.printDataBuffer();
	 }
}

void yyerror(const char * message)
{
    throw parsingExceptions(parsingExceptions::ERR_SYN, yylineno);
}