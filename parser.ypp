%{
	#include "attributes.h"
	#include <iostream>
	#include <stdlib.h>

	using namespace std;
    extern int yylineno;
	extern int yylex();		// do they both need to be extern?
    void yyerror(const char * message);

    #define TRY_AND_CATCH(statement_to_try)                             \
        try{                                                            \
            (statement_to_try);                                         \
        }catch(parsingExceptions& e){                                   \
             throw parsingExceptions(e.err_type, yylineno, e.id);       \
        }

    #define EMIT_TEXT(string) buffer.emit(string)
    #define EMIT_DATA(string) buffer.emitData(string)
    #define EXC static_cast<parsedExp*>
    #define STC static_cast<parsedStatement*>

	scopes* scopesList;
%}

%token B
%token BYTE BOOL INT VOID TRUE FALSE RETURN WHILE BREAK SC COMMA ID NUM STRING
%right IF
%right ASSIGN
%left OR
%left AND
%left EQ_OP
%nonassoc RELOP
%left PLUS_MINUS
%left MUL_DIV
%right NOT
%left LPAREN
%left RPAREN
%nonassoc ELSE
%left LBRACE LBRACK RBRACE RBRACK

%%

Program	:	Funcs
    	;

Funcs :
		|	Function Funcs
		;
Function : FunctionDefinition LBRACE Statements RBRACE_t      {if(PRINT_DEBUG) cout << "parsed function" << endl;}
        ;


FunctionDefinition : RetType ID LPAREN Formals RPAREN {TRY_AND_CATCH(scopesList->addFunction(*$1,*$2,*$4));
                                                       TRY_AND_CATCH(scopesList->newFunctionScope(*$4));
                                                       delete $1; delete $2; delete $4;
                                                       if(PRINT_DEBUG) cout <<"added a new function " << $2->getName() << endl;}
                   ;

RetType : Type          {$$ = $1;}
        | VOID          {$$ = new parsedData(Type(Type::VOID));}
        ;

Formals	:	                    {$$ = new parsedData();}  //Lior
		|	FormalsList         {$$ = $1;}
		;

Type_ID : Type ID       {if(scopesList->containsIdName($2->getName()))
                            throw parsingExceptions(parsingExceptions::ERR_DEF, yylineno, $2->getName());

                         $$ = new parsedData($1->single_var.type, $2->single_var.name);
                         delete $1; delete $2;
                        }    //Lior
		;

FormalsList :   FormalDecl {$$ = new parsedData(*$1, IS_CALL);
                            delete $1;
                           }
            |   FormalDecl COMMA FormalsList {$$ = new parsedData(*$1,*$3) ;
                                              delete $1; delete $3;
                                             }
            ;

FormalDecl  :   Type_ID                     {TRY_AND_CATCH($$ = new parsedData(*$1));
                                             delete $1;
                                            }
            |   Type_ID LBRACK NUM_T RBRACK {TRY_AND_CATCH($$ = new parsedData(*$1, *$3, IS_ARRAY));
                                             delete $1; delete $3;
                                            }
            ;

NUM_T :	NUM NUM_T2  {try{$$ = new parsedData($2->single_var.type, $1->single_var.value);delete $1; delete $2;}
                     catch(parsingExceptions& e){throw parsingExceptions(e.err_type, yylineno, e.id);}}
		;

NUM_T2 :                {$$ = new parsedData(Type(Type::INTEGER));}     //Lior
       | B              {$$ = new parsedData(Type(Type::BYTE));}    //Lior
       ;


Statements  :   Statement { $$ = new parsedStatement(*$1); delete $1;}
            |   Statement Statements {
                                      $$ = new parsedStatement();
                                      STC$$->breakList = mergeVectors(STC$1->breakList,STC$2->breakList);
                                      delete $1; delete $2;
                                     }
            ;

Statement : 	LBRACE_t Statements RBRACE_t {$$ = $2;}
			|	Type_ID SC          {TRY_AND_CATCH(scopesList->addIdNotArray(*$1));
                                     $$ = new parsedStatement();
			                         delete $1;
			                         }
			|	Type_ID ASSIGN Exp SC           {TRY_AND_CATCH(scopesList->addIdNotArray(*$1));
			                                     TRY_AND_CATCH(scopesList->verifyAssign(*$1,*$3));
			                                     $$ = new parsedStatement();
						                         delete $1; delete $3; }
			|	Type_ID LBRACK NUM_T RBRACK SC      {TRY_AND_CATCH(scopesList->addIdArray(*$1,*$1,*$3));
			                                         $$ = new parsedStatement();
			                                         delete $1; delete $3;
			                                        }
			|	ID ASSIGN Exp SC        {if (!scopesList->containsIdName($1->getName()))
			                                throw parsingExceptions(parsingExceptions::ERR_UNDEF,yylineno, $1->getName() );

                                         TRY_AND_CATCH(scopesList->verifyAssign(*$1,*$3));

                                         delete $1; delete $3;
                                        }
			|	ID LBRACK Exp RBRACK ASSIGN Exp SC  {if (!scopesList->containsIdName($1->getName()))
			                                            throw parsingExceptions(parsingExceptions::ERR_UNDEF,yylineno, $1->getName());

                                                     TRY_AND_CATCH(scopesList->verifyAssignToArray(*$1,*$3,*$6));

                                                     delete $1; delete $3; delete $6;
                                                    }
			|	Call SC             {$$ = new parsedStatement();
			                        // emit code for calling
			                        delete $1;
			                        }
			|	RETURN SC           {TRY_AND_CATCH(scopesList->verifyReturnTypeVoid());
			                        $$ = new parsedStatement(); // so delete later will be possible
			                        // code for return from a function

			                        }
			|	RETURN Exp SC       {TRY_AND_CATCH(scopesList->verifyReturnType(*$2));
					                 $$ = new parsedStatement(); // so delete later will be possible

                                     string s1 = "add $r0, $0, ";
                                     string s2 = EXC$2->reg.toString();
                                     EMIT_TEXT(s1 + s2);
                                     // code for return from a function

					                 delete $2;
					                }

            | If_Begin If_Continue {
                                    $$ = new parsedStatement();

                                    STC$$->breakList = mergeVectors(STC$1->breakList,STC$2->breakList);
                                    buffer.bpatch(STC$1->trueList, STC$2->ifTrueLabel);
                                    buffer.bpatch(STC$1->falseList, STC$2->ifFalseLabel);

                                    delete $1; delete $2;
                                   }

           	|	While_Statement     {$$ = $1;}
			|	BREAK SC            {TRY_AND_CATCH(scopesList->verifyBreakBlock());
			                         $$ = new parsedStatement();
			                         STC$$->breakList.push_back(EMIT_TEXT("j "));
			                        }
			;

If_Begin    :  IF LPAREN Exp {if(!$3->isBool()) throw parsingExceptions(parsingExceptions::ERR_MISMATCH,yylineno);
                              $$ = new parsedStatement(*$3);
                              delete $3;
                             }
            ;

If_Continue :   RPAREN Open_Scope Statement {scopesList->removeScope();

                $$ = new parsedStatement();
                STC$$->breakList = STC$3->breakList;
                STC$$->ifTrueLabel = STC$3->beginLabel;
                STC$$->ifFalseLabel = STC$$->beginLabel; // combina, same as below.

                delete $3;
            }
            |   RPAREN Open_Scope Statement ELSE Go_To_End_of_If_Statement CloseScope Open_Scope Statement {scopesList->removeScope();

                $$ = new parsedStatement();

                STC$$->breakList = mergeVectors(STC$3->breakList,STC$8->breakList);

                buffer.bpatch(STC$5->nextList,STC$$->beginLabel); // combina, at $$ creation a mew label is created, "beginLabel" name is misleading
                STC$$->ifTrueLabel = STC$3->beginLabel;
                STC$$->ifFalseLabel = STC$8->beginLabel;

                delete $3; delete $5; delete $8;
            }
            ;

Go_To_End_of_If_Statement : {
                             $$ = new parsedStatement();
                             STC$$->nextList.push_back(EMIT_TEXT("j "));
                            }

Open_Scope : { scopesList->newRegularScope(false);}
           ;

CloseScope : { scopesList->removeScope(); }
           ;

While_Statement : While_Open Statement {scopesList->removeScope();
                                        $$ = new parsedStatement(); // for the delete at higher levels

                                        buffer.bpatch(STC$1->trueList, STC$2->beginLabel);
                                        buffer.bpatch(STC$2->breakList, STC$$->beginLabel);
                                        buffer.bpatch(STC$1->falseList,STC$$->beginLabel);

                                        string s1 = "j ";
                                        string s2 = STC$1->beginLabel;
                                        EMIT_TEXT(s1 + s2);

                                        delete $1; delete $2;
                                       }
            ;

While_Open : WHILE LPAREN Exp RPAREN {TRY_AND_CATCH(scopesList->verifyExpIsBool(*$3));
                                      TRY_AND_CATCH(scopesList->newRegularScope(true));

                                      $$ = new parsedStatement();
                                      STC$$->trueList = EXC$3->trueList;
                                      STC$$->falseList = EXC$3->falseList;
                                      delete $3;}
        ;

//end of need to fix if

//TODO Inbar call returns type
Call	:	ID LPAREN ExpList RPAREN    {try {scopesList->verifyFunctionCall(*$1,*$3);}
                                            catch(parsingExceptions& e){
                                            if(e.err_type == parsingExceptions::ERR_PROTOTYPE_MISMATCH)
                                                throw parsingExceptions(e.err_type,
                                                yylineno, $1->getName(),scopes::listToVector(scopesList->getFunction($1->getName()).inputTypes));
                                            else
                                                throw parsingExceptions(e.err_type,
                                                yylineno, $1->getName());
                                            }
                                         $$ = new parsedExp((scopesList->getFunction($1->getName())).return_type);
                                         delete $1; delete $3;}
		|	ID LPAREN RPAREN            {try {scopesList->verifyNoParametersFunctionCall(*$1);
		                                    }catch(parsingExceptions& e){
		                                        if(e.err_type == parsingExceptions::ERR_PROTOTYPE_MISMATCH)
                                                    throw parsingExceptions(e.err_type,
                                                    yylineno, $1->getName(), scopes::listToVector(scopesList->getFunction($1->getName()).inputTypes));
                                                else throw parsingExceptions(e.err_type,yylineno, $1->getName());
                                        }
		                                 $$ = new parsedExp((scopesList->getFunction($1->getName())).return_type);
		                                 delete $1;}
		;
//TODO Lior
ExpList:    Exp ExpList2 {  $$ = new parsedData(*$1,*$2) ;
		                                delete $1; delete $2;}

ExpList2 :                  { $$ = new parsedData(IS_CALL); }
         | COMMA ExpList    { $$ = $2;}
         ;

Type	:	INT              {$$ = new parsedData(Type(Type::INTEGER));}
		|	BYTE             {$$ = new parsedData(Type(Type::BYTE));}
		| 	BOOL             {$$ = new parsedData(Type(Type::BOOL));}
		;

Exp		:	LPAREN Exp RPAREN       {$$ = $2;}
		| 	ID LBRACK Exp RBRACK    {if (!scopesList->containsIdName($1->getName()))  //ID doesn't exist
                                        throw parsingExceptions(parsingExceptions::ERR_UNDEF,yylineno, $1->getName());
                                     if(!(scopesList->getId($1->getName()).type.kind == Type::ARRAY)) //ID is not an array
                                        throw parsingExceptions(parsingExceptions::ERR_MISMATCH,yylineno);
                                     if (!($3->isInteger())) // Exp is not a numeric type
                                        throw parsingExceptions(parsingExceptions::ERR_INVALID_ARRAY_SIZE, yylineno, $1->getName());

                                     $$ = new parsedExp(scopesList->getId($1->getName()).type.arrayType);

                                     EXC$$->reg = regAlloc();
                                     EXC$$->regType = parsedExp::value;

                                     // runtime check that Exp value is smaller than array size
                                     EMIT_TEXT(codeGenerator::arrayOverflowCheck(scopesList->getId($1->getName()).type.arrayLength,EXC$3->reg));

                                     string s1 = "lw ";
                                     string s2 = EXC$$->reg.toString();
                                     string s3 = ", ";
                                     string s4 = codeGenerator::array_A_at_location_n(scopesList->getId($1->getName()),EXC$3->reg);

                                     EMIT_TEXT(s1 + s2 + s3 + s4);

                                     regFree(EXC$3->reg);
                                     delete $1; delete $3;
		                            }
		| 	Exp PLUS_MINUS Exp      {TRY_AND_CATCH($$ = new parsedExp(*$1,*$3, MATH_OP));
		                             EXC$$->reg = regAlloc();
                                     EXC$$->regType = parsedExp::value;

                                     string s1 = codeGenerator::arithmeticOpToString($2->pd_op);
                                     string s2 = EXC$$->reg.toString();  //destination
                                     string s3 = ", ";
                                     string s4 = EXC$3->reg.toString();
                                     string s5 = ", ";
                                     string s6 = EXC$1->reg.toString();

                                     EMIT_TEXT(s1 + s2 + s3 + s4 + s5 + s6);
                                     if($$->single_var.type.kind == Type::BYTE){
                                        EMIT_TEXT(codeGenerator::byteArithmeticMasking(EXC$$->reg));
                                     }
                                     delete $1; delete $3;
                                     }
		|	Exp MUL_DIV Exp         {TRY_AND_CATCH($$ = new parsedExp(*$1,*$3, MATH_OP));
		                             EXC$$->reg = regAlloc();
		                             EXC$$->regType = parsedExp::value;

		                             string s1 = codeGenerator::arithmeticOpToString($2->pd_op);

		                             if(s1 == "div "){
		                                EMIT_TEXT(codeGenerator::divisionByZeroCheck(EXC$3->reg));
		                             }

		                             string s2 = EXC$$->reg.toString();  //destination
		                             string s3 = ", ";
                                     string s4 = EXC$3->reg.toString();
                                     string s5 = ", ";
                                     string s6 = EXC$1->reg.toString();

                                     EMIT_TEXT(s1 + s2 + s3 + s4 + s5 + s6);
                                     if($$->single_var.type.kind == Type::BYTE){
                                        EMIT_TEXT(codeGenerator::byteArithmeticMasking(EXC$$->reg));
                                     }

                                     regFree(EXC$1->reg);
                                     regFree(EXC$3->reg);
                                     delete $1; delete $3;
                                     }
		| 	ID                      {if (!scopesList->containsIdName($1->getName()))
		                                throw parsingExceptions(parsingExceptions::ERR_UNDEF,yylineno, $1->getName());

		                             $$ = new parsedExp(scopesList->getId($1->getName()).type);
		                             EXC$$->reg = regAlloc();

                                     string s1 = "move ";
                                     string s2 = EXC$$->reg.toString();
                                     string s3 = ", ";
		                             string s4;

		                             if($$->kind == parsedData::DK_ARRAY){
		                                EXC$$->regType = parsedExp::reference;
		                                s4 = codeGenerator::idLocation(scopesList->getId($1->getName())); // debug : make sure there are no too much/too little dereferences
		                             }
		                             else{
                                        EXC$$->regType = parsedExp::value;

                                        string temp1 = "(";
                                        string temp2 = ")";
                                        s4 =  temp1 + codeGenerator::idLocation(scopesList->getId($1->getName())) + temp2;
		                             }

		                             EMIT_TEXT(s1 + s2 + s3 + s4);

		                             delete $1;
		                            }

		|	Call                    {$$ = new parsedExp(*$1);
                                     EXC$$->reg =  regAlloc();
                                     EXC$$->regType = parsedExp::value;
                                     // calling the function code
                                     string s1 = "move $r0, ";
                                     string s2 = EXC$$->reg.toString();
                                     EMIT_TEXT(s1 + s2);
                                    }

        |	NUM_T	                {$$ = new parsedExp(*$1);
                                    EXC$$->reg =  regAlloc();
                                    EXC$$->regType = parsedExp::value;
                                    string s1 = "li "; // load immediate
                                    string s2 = EXC$$->reg.toString();
                                    string s3 = ", ";
                                    string s4 = num_to_string($$->single_var.value);
                                    EMIT_TEXT(s1 + s2 + s3 + s4);
                                    }

        |	STRING                  {$$ = new parsedExp(Type(Type::STRING));    // return string type
                                     EXC$$->reg =  regAlloc();
                                     EXC$$->regType = parsedExp::reference;

                                     // create string in .data segment
                                     string s1 = buffer.genDataLabel();
                                     string s2 = ".asciiz \"";
                                     string s3 = $1->single_var.name;
                                     string s4 = "\"";
                                     EMIT_DATA(s1 + s2 + s3 + s4);

                                     // generate code " la  $$->reg, <string location label>"
                                     string s12 = "la "; // load address, need to verify it works with labels
                                     string s22 = EXC$$->reg.toString();
                                     string s32 = ", ";
                                     string s42 = s1;
                                     EMIT_TEXT(s12 + s22 + s32 + s42);

                                    }
        |	TRUE	                {$$ = new parsedExp(Type(Type::BOOL)); // return bool type
                                     EXC$$->trueList.push_back(EMIT_TEXT("j "));
                                    }

		|	FALSE	                {$$ = new parsedExp(Type(Type::BOOL)); // return bool type
		                             EXC$$->falseList.push_back(EMIT_TEXT("j "));
                                    }

		|	NOT Exp	                {TRY_AND_CATCH($$ = new parsedExp(*$2, BOOL_OP));
		 		                     EXC$$->trueList = EXC$2->falseList;
		 		                     EXC$$->falseList = EXC$2->trueList;
		 		                     delete $2;
		 		                    }
		|	Exp OR Exp              {TRY_AND_CATCH($$ = new parsedExp(*$1,*$3, BOOL_OP));
                                        if(PRINT_DEBUG)
        		                            cout << "parsed exp OR exp: "
        		                            << $1->getName() << " " << $3->getName()
        		                            << endl;

                                     buffer.bpatch(EXC$1->falseList,EXC$3->beginLabel);
                                     EXC$$->falseList = EXC$3->falseList;
                                     EXC$$->trueList = mergeVectors(EXC$3->trueList,EXC$1->trueList);

        		                     delete $1; delete $3;
                                    }  // make sure Exp and Exp are of type bool
		|	Exp AND Exp	            {TRY_AND_CATCH($$ = new parsedExp(*$1,*$3, BOOL_OP));
                                        if(PRINT_DEBUG)
        		                            cout << "parsed exp AND exp: "
        		                            << $1->getName() << " " << $3->getName()
        		                            << endl;

        		                     buffer.bpatch(EXC$1->trueList,EXC$3->beginLabel);
                                    EXC$$->trueList = EXC$3->trueList;
                                    EXC$$->falseList = mergeVectors(EXC$3->falseList,EXC$1->falseList);

        		                     delete $1; delete $3;
                                    }     // make sure Exp and Exp are of type bool
		|	Exp EQ_OP Exp           {TRY_AND_CATCH($$ = new parsedExp(*$1,*$3, REL_OP));
		                                if(PRINT_DEBUG)
		                                    cout << "parsed exp EQ_OP exp: "
		                                     << $1->getName() << " " << $3->getName()
		                                     << endl;

                                     string s1 = codeGenerator::opToBranchString($2->pd_op); // branch type
                                     string s2 = EXC$1->reg.toString();
                                     string s3 = ", ";
                                     string s4 = EXC$3->reg.toString();
                                     string s5 = ", ";
                                     EXC$$->trueList.push_back(EMIT_TEXT(s1 + s2 + s3 + s4 + s5));
                                     EXC$$->falseList.push_back(EMIT_TEXT("j "));

                                     regFree(EXC$1->reg);
                                     regFree(EXC$3->reg);
                                     delete $1; delete $3;
                                     }
		|	Exp RELOP Exp           {TRY_AND_CATCH($$ = new parsedExp(*$1,*$3, REL_OP));
		                                if(PRINT_DEBUG)
        		                             cout << "parsed exp RELOP exp: "
        		                             << $1->getName() << " " << $3->getName()
        		                             << endl;

		                             string s1 = codeGenerator::opToBranchString($2->pd_op); // branch type
                                     string s2 = EXC$1->reg.toString();
                                     string s3 = ", ";
                                     string s4 = EXC$3->reg.toString();
                                     string s5 = ", ";
                                     EXC$$->trueList.push_back(EMIT_TEXT(s1 + s2 + s3 + s4 + s5));
                                     EXC$$->falseList.push_back(EMIT_TEXT("j "));

                                     regFree(EXC$1->reg);
                                     regFree(EXC$3->reg);
		                             delete $1; delete $3;
		                            }
		;


LBRACE_t : LBRACE { scopesList->newRegularScope(false); }
         ;

RBRACE_t : RBRACE{ scopesList->removeScope(); }
         ;

%%

int main()
{
	// initSystem
	scopesList = new scopes();
	scopesList->scopesList.push_front( scope(0,false));
	Type tmp;
    scopesList->addInitialFunction( Type(tmp.VOID),string("print"), Type(tmp.STRING));
    scopesList->addInitialFunction( Type(tmp.VOID),string("printi"), Type(tmp.INTEGER));

    try{
	    yyparse();
	}catch(parsingExceptions& e){
	    scopesList->need_to_print = false;
	}
	catch(...){
	    scopesList->need_to_print = false;
        if(PRINT_DEBUG) cout << "Something wierd happened!!!" << endl;
	}
	if(scopesList->need_to_print){      //check valid main function in the scopelist
	    if(!scopesList->containsFunctionName("main")){
   	        scopesList->need_to_print = false;
            errorMainMissing();
    	}else{
    	    function main_func = scopesList->getFunction("main");
    	    if((main_func.return_type.kind != main_func.return_type.VOID ||
    	            !main_func.inputTypes.empty())){
                scopesList->need_to_print = false;
                errorMainMissing();
                if(PRINT_DEBUG) cout <<"in the if to check the main function" << endl;
            }
        }
    }
	delete scopesList;
}

void yyerror(const char * message)
{
    throw parsingExceptions(parsingExceptions::ERR_SYN, yylineno);
}