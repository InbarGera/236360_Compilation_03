%{
	#include "attributes.h"
	#include <iostream>
	#include <stdlib.h>

	using namespace std;

	extern int yylex();		// do they both need to be extern?
	int yyerror(char * message);
%}


%token B
%token BYTE BOOL INT VOID TRUE FALSE RETURN IF ELSE WHILE BREAK SC COMMA ID NUM STRING
%right ASSIGN
%nonassoc RELOP
%left EQ_OP
%left OR
%left AND
%left PLUS_MINUS
%left MUL_DIV
%left NOT
%left LBRACE LBRACK LPAREN RBRACE RBRACK RPAREN

%type<exp> Exp

%%


Program	:	Funcs
	;

Funcs 	:	
		|	RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE Funcs
		;
		
RetType : Type
		| VOID
		;
		
Formals	:	
		|	FormalsList
		;
		
Type_ID : Type ID
		;
		
FormalsList	:	FormalDecl FormalsList2
			;

FormalsList2	:	
				|	COMMA FormalsList
				;

FormalDecl	:	Type_ID	FormalDecl2
			;

FormalDecl2	:	
			| 	LBRACK NUM_T RBRACK {$$.parm_type = $2.parm_type}
			;

NUM_T	:	NUM NUM_T2 {$$.parm_type = ($2.parm_type == BYTE? BYTE : INT);
						$$.parm_val = $1.parm_val;							}
		;
		
NUM_T2	: {$$.parm_type = NOTHING;}
		| B {$$.parm_type = BYTE;}
		;

Statements : Statement
			| Statement Statements
			;

Statement	:	LBRACE Statements RBRACE
			|	Type_ID SC
			|	Type_ID ASSIGN Exp SC
			|	Type_ID LBRACK NUM_T RBRACK SC
			|	ID ASSIGN Exp SC
			|	ID LBRACK Exp RBRACK ASSIGN Exp SC
			|	Call SC
			|	RETURN SC
			|	RETURN Exp SC
			|	IF_STATE
			|	WHILE LPAREN Exp RPAREN Statement
			|	BREAK SC
			;
			
IF_STATE	:	IF LPAREN Exp RPAREN Statement IF_STATE_ELSE
			;

IF_STATE_ELSE	:	
				|	ELSE Statement
				;

Call	:	ID LPAREN ExpList RPAREN
		|	ID LPAREN RPAREN
		;

ExpList	:	Exp
		|	Exp COMMA ExpList
		;
		
Type	:	INT
		|	BYTE
		| 	BOOL
		;
		
Exp		:	LPAREN Exp RPAREN
		| 	ID LBRACK Exp RBRACK
		| 	Exp PLUS_MINUS Exp {$$.parm_type = $1.checkBinOpParmType($3);
		                        $$.parm_val = $1.makeOp($2,$3);
		                        }
		|	Exp MUL_DIV Exp     {$$.parm_type = $1.checkBinOpParmType($3);
                                 $$.parm_val = $1.makeOp($2,$3);
                                }
		| 	ID
		|	Call
		|	NUM_T	{$$.parm_type = $1.parm_type;	$$.parm_val = $1.parm_val}
		|	STRING
		|	TRUE	{$$.parm_type = BOOL; $$.parm_val = 1;}
		|	FALSE	{$$.parm_type = BOOL; $$.parm_val = 0;}
		|	NOT Exp	{if($2.parm_type != BOOL){
							yyerror();		//TODO
						}else{
							$$.parm_type = BOOL;
							$$.parm_val = 1-$2.parm_val;
						}
					}
		|	Exp OR Exp { $$.parm_type = BOOL;
						 $$.parm_val = $1.makeOP($2,$3);
						}

		|	Exp AND Exp	{ $$.parm_type = BOOL;
                          $$.parm_val = $1.makeOP($2,$3);
                        }
		|	Exp EQ_OP Exp { $$.parm_type = BOOL;
                            $$.parm_val = $1.makeOP($2,$3);
                          }
		|	Exp RELOP Exp { $$.parm_type = BOOL;
                            $$.parm_val = $1.makeOP($2,$3);
                           }
		;

%%

int main()
{
	yyparse();
}

int yyerror(char * message)
{
	cout<<"Parse error: "<<message<<endl;
	exit(0);
}