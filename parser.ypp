%{
	#include "attributes.h"
	#include <iostream>
	#include <stdlib.h>

	using namespace std;

	extern int yylex();		// do they both need to be extern?
	extern int yyerror(char * message);

	scopes* scopesList;
%}

%token B
%token BYTE BOOL INT VOID TRUE FALSE RETURN WHILE BREAK SC COMMA ID NUM STRING
%right IF
%nonassoc RPAREN
%nonassoc ELSE
%right ASSIGN
%nonassoc RELOP
%left EQ_OP
%left OR
%left AND
%left PLUS_MINUS
%left MUL_DIV
%left NOT
%left LBRACE LBRACK LPAREN RBRACE RBRACK

%%

Program	:	Funcs
    	;

Funcs :
		|	Function Funcs
		;
Function : FunctionDefinition LBRACE_t Statements RBRACE_t
        ;


FunctionDefinition : RetType ID LPAREN Formals RPAREN {scopesList>addFunction($1,$2,$4); scopesList->newFunctionScope($2);}
                   ;

RetType : Type          {$$ = $1;}      //Lior
		| VOID          {$$ = new parsedType(VOID);}    //Lior
		;

Formals	:	                    {$$ = new parsedData}  //Lior
		|	FormalsList         {$$ = $1}             //Lior
		;

Type_ID : Type ID       {$$ = new parsedTpID($1, $2);}    //Lior
		;

FormalsList	:	FormalDecl FormalsList2         { /*$$ = { FormalDecl merge FormalsList2 } ;*/ }   //Lior
			;

FormalsList2 :       {/* $$ = {new empty list or retType}; */}    //Lior
			 |	COMMA FormalsList       {/* $$ = { merge FormalsList to $$} ;*/}    //Lior
			 ;

FormalDecl :	Type_ID	FormalDecl2     { addId($1,$1,$2);
                                            /*$$ = new retType list with one node contains the data of $! and $2 */}     //Lior
			;

FormalDecl2	:
			| 	LBRACK NUM_T RBRACK     {/*add information about array  */}         //Lior
			;

NUM_T :	NUM NUM_T2  {$$ = new parsedNum($1, $2); /*TODO add type/byte check */	}    //Lior
		;

NUM_T2 :                 {$$ = new parsedNum();}     //Lior
		| B              {$$ = new parsedNum(BYTE);}    //Lior
		;


Statements :    Statement     // done
			|   Statement Statements    // done
			;

Statement : 	LBRACE_t Statements RBRACE_t        // done
			|	Type_ID SC          {scopesList->addIdNotArray($1)}         // done
			|	Type_ID ASSIGN Exp SC           {scopesList->addIdNotArray($1); scopesList->verifyAssign($1,$3)}     // done
			|	Type_ID LBRACK NUM_T RBRACK SC      {scopesList->addId($1,$1,$3)}      // done
			|	ID ASSIGN Exp SC        {scopesList->verifyAssign($1,$3)}       // done
			|	ID LBRACK Exp RBRACK ASSIGN Exp SC  {scopesList->verifyAssignToArray($1,$3,$6)}         // done
			|	Call SC             // done
			|	RETURN SC           {scopesList->verifyReturnTypeVoid();}       // done
			|	RETURN Exp SC       {scopesList->verifyReturnType($2);}       // done
			|   IF LPAREN Exp RPAREN Open_Scope Statement { scopesList->removeScope(); }
			|   IF LPAREN Exp RPAREN Open_Scope Statement ELSE CloseScope Open_Scope Statement { scopesList->removeScope(); }
			|	While_Statement
			|	BREAK SC            {scopesList->verifyBreakBlock();}        // done
			|   SC
			;

Open_Scope : { scopesList->newRegularScope(false);}
           ;

CloseScope : { scopesList->removeScope(); }
           ;

While_Statement : While_Open Statement { scopesList->removeScope(); }          // done
            ;

While_Open : WHILE LPAREN Exp RPAREN {scopesList->verifyExpIsBool($3); scopesList->newRegularScope(true); }    // done
        ;

//end of need to fix if

//TODO Inbar call returns type
Call	:	ID LPAREN ExpList RPAREN    {scopesList->verifyFunctionCall($1,$3);    ________   $$ = new parsedCall($1,$3);}  /* just make sure that Id is a valid function and ExpLis is the same as Id input list */
		|	ID LPAREN RPAREN            {scopesList->verifyNoParametersFunctionCall($1); _________ $$ = new parsedCall($1);}     /* make sure Id is a valid function and its input list is empty */
		;
//TODO Lior
ExpList:    Exp ExpList2 { }// $$ = new parsedExpList($1,$2) ;}

ExpList2 :                  { $$ = new parsedExpList(); }
         | COMMA ExpList    { $$ =$2; }
         ;

Type	:	INT              {$$ = new parsedType(INT);} // to return new type with appropriate type
		|	BYTE             {$$ = new parsedType(BYTE);}
		| 	BOOL             {$$ = new parsedType(BOOL);}
		;

Exp		:	LPAREN Exp RPAREN       {$$ = $2;}
		| 	ID LBRACK Exp RBRACK    {$$ = new parsedExp($1,$3);} // make sure Id ia an array, Exp is int/byte, getting the value
		| 	Exp PLUS_MINUS Exp      {$$ = new parsedExp($1,parsedOp(yytext),$3);}
		|	Exp MUL_DIV Exp         {$$ = new parsedExp($1,parsedOp(yytext),$3);}
		| 	ID                      {$$ = $1;} // make sure ID is declared, and return its type
		|	Call
		|	NUM_T	                {$$ = $1;}
		|	STRING                  {$$ = new parsedExp($1);} // return string type
		|	TRUE	                {$$ = new parsedExp(true);} // return bool type
		|	FALSE	                {$$ = new parsedExp(false);} // return bool type
		|	NOT Exp	                {$$ = $1; }  // make sure Exp type is bool
		|	Exp OR Exp              {$$ = new parsedExp($1,parsedOp("||"),$3);}  // make sure Exp and Exp are of type bool
		|	Exp AND Exp	            {$$ = new parsedExp($1,parsedOp("&&"),$3);}     // make sure Exp and Exp are of type bool
		|	Exp EQ_OP Exp           {$$ = new parsedExp($1,parsedOp(yytext),$3);}     // make sure Exp and Exp are of type bool
		|	Exp RELOP Exp           {$$ = new parsedExp($1,parsedOp(yytext),$3);}       // make sure Exp and Exp are COMPATIABLE types
		;

LBRACE_t : LBRACE { scopesList->newRegularScope(false); }
         ;

RBRACE_t : RBRACE{ scopesList->removeScope(); }
         ;

%%

int main()
{
	// initSystem
	scopesList = new scopes();
	scopesList->push_front(new scope(0,false));

    addInitialFunction(new Type(Type.VOID),"print",new Type(Type.STRING));
    addInitialFunction(new Type(Type.VOID),"printi",new Type(Type.INTEGER));

	yyparse();
	delete scopesList;
}

int yyerror(char * message)
{
	cout<<"Parse error: "<<message<<endl;
	exit(0);
}
