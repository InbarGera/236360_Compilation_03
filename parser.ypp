%{
	#include "attributes.h"
	#include <iostream>
	#include <stdlib.h>

	using namespace std;
    extern int yylineno;
	extern int yylex();		// do they both need to be extern?
    void yyerror(const char * message);

    #define TRY_AND_CATCH(statement_to_try)                             \
        try{                                                            \
            (statement_to_try);                                         \
        }catch(parsingExceptions& e){                                   \
             throw parsingExceptions(e.err_type, yylineno, e.id);       \
        }

	scopes* scopesList;
%}

%token B
%token BYTE BOOL INT VOID TRUE FALSE RETURN WHILE BREAK SC COMMA ID NUM STRING
%right IF
%nonassoc RPAREN
%nonassoc ELSE
%right ASSIGN
%nonassoc RELOP
%left EQ_OP
%left OR
%left AND
%left PLUS_MINUS
%left MUL_DIV
%left NOT
%left LBRACE LBRACK LPAREN RBRACE RBRACK

%%

Program	:	Funcs
    	;

Funcs :
		|	Function Funcs
		;
Function : FunctionDefinition LBRACE Statements RBRACE_t      {if(PRINT_DEBUG) cout << "parsed function" << endl;}
        ;


FunctionDefinition : RetType ID LPAREN Formals RPAREN {TRY_AND_CATCH(scopesList->addFunction(*$1,*$2,*$4));
                                                        TRY_AND_CATCH(scopesList->newFunctionScope(*$4));
                                                        delete $1; delete $2; delete $4;
                                                        if(PRINT_DEBUG) cout <<"added a new function " << $2->getName() << endl;}
                   ;

RetType : Type          {$$ = $1;}
		| VOID          {$$ = new parsedData(Type(Type::VOID));}
		;

Formals	:	                    {$$ = new parsedData();}  //Lior
		|	FormalsList         {$$ = $1;}
		;

Type_ID : Type ID       {if(scopesList->containsIdName($2->getName()))
                            throw parsingExceptions(parsingExceptions::ERR_DEF, yylineno, $2->getName());
                            $$ = new parsedData($1->single_var.type, $2->single_var.name);
                            delete $1; delete $2;}    //Lior
		;

FormalsList :   FormalDecl {$$ = new parsedData(*$1, IS_CALL);
                            delete $1; }
            |   FormalDecl COMMA FormalsList {$$ = new parsedData(*$1,*$3) ;
                                              delete $1; delete $3;}
            ;

FormalDecl  :   Type_ID                     {TRY_AND_CATCH($$ = new parsedData(*$1));

                                             delete $1; }
            |   Type_ID LBRACK NUM_T RBRACK {TRY_AND_CATCH($$ = new parsedData(*$1, *$3, IS_ARRAY));
                                             delete $1; delete $3;}
            ;

NUM_T :	NUM NUM_T2  {try{$$ = new parsedData($2->single_var.type, $1->single_var.value);delete $1; delete $2;}
                     catch(parsingExceptions& e){throw parsingExceptions(e.err_type, yylineno, e.id);}}
		;

NUM_T2 :                 {$$ = new parsedData(Type(Type::INTEGER));}     //Lior
		| B              {$$ = new parsedData(Type(Type::BYTE));}    //Lior
		;


Statements  :   Statement
			|   Statement Statements
			;

Statement : 	LBRACE_t Statements RBRACE_t
			|	Type_ID SC          {TRY_AND_CATCH(scopesList->addIdNotArray(*$1));

			                         delete $1;}
			|	Type_ID ASSIGN Exp SC           {TRY_AND_CATCH(scopesList->addIdNotArray(*$1));
			                                     TRY_AND_CATCH(scopesList->verifyAssign(*$1,*$3));
						                         delete $1; delete $3; }
			|	Type_ID LBRACK NUM_T RBRACK SC      {TRY_AND_CATCH(scopesList->addIdArray(*$1,*$1,*$3));
			                                          delete $1; delete $3; }
			|	ID ASSIGN Exp SC        {if (scopesList->containsIdName($1->getName())){
                                                  TRY_AND_CATCH(scopesList->verifyAssign(*$1,*$3));
                                                  delete $1; delete $3;
                                            }
                                         	else
                                         	   throw parsingExceptions(parsingExceptions::ERR_UNDEF,
                                         	                          yylineno, $1->getName() );  //TODO
                                         }
			|	ID LBRACK Exp RBRACK ASSIGN Exp SC  {if (scopesList->containsIdName($1->getName())){
                                                         TRY_AND_CATCH(scopesList->verifyAssignToArray(*$1,*$3,*$6));
                                                        delete $1; delete $3; delete $6;
                                                      } else
                                                         throw parsingExceptions(parsingExceptions::ERR_UNDEF,
                                                                            yylineno, $1->getName());  //TODO
                                                    }
			|	Call SC             {delete $1;}
			|	RETURN SC           {TRY_AND_CATCH(scopesList->verifyReturnTypeVoid());}
			|	RETURN Exp SC       {TRY_AND_CATCH(scopesList->verifyReturnType(*$2));
					                 delete $2;}

            | If_Begin If_Continue
           	|	While_Statement
			|	BREAK SC            {TRY_AND_CATCH(scopesList->verifyBreakBlock());}
			;

If_Begin    :  IF LPAREN Exp {if(!$3->isBool()) throw parsingExceptions(parsingExceptions::ERR_MISMATCH,yylineno); delete $3;}
            ;

If_Continue :   RPAREN Open_Scope Statement {scopesList->removeScope();}
            |   RPAREN Open_Scope Statement ELSE CloseScope Open_Scope Statement {scopesList->removeScope();}
            ;



Open_Scope : { scopesList->newRegularScope(false);}
           ;

CloseScope : { scopesList->removeScope(); }
           ;

While_Statement : While_Open Statement {scopesList->removeScope();}
            ;

While_Open : WHILE LPAREN Exp RPAREN {TRY_AND_CATCH(scopesList->verifyExpIsBool(*$3));
                                      TRY_AND_CATCH(scopesList->newRegularScope(true));
                                      delete $3;}
        ;

//end of need to fix if

//TODO Inbar call returns type
Call	:	ID LPAREN ExpList RPAREN    {try {scopesList->verifyFunctionCall(*$1,*$3);}
                                            catch(parsingExceptions& e){
                                            if(e.err_type == parsingExceptions::ERR_PROTOTYPE_MISMATCH)
                                                throw parsingExceptions(e.err_type,
                                                yylineno, $1->getName(),scopes::listToVector(scopesList->getFunction($1->getName()).inputTypes));
                                            else
                                                throw parsingExceptions(e.err_type,
                                                yylineno, $1->getName());
                                            }
                                         $$ = new parsedExp((scopesList->getFunction($1->getName())).return_type);
                                         delete $1; delete $3;}
		|	ID LPAREN RPAREN            {try {scopesList->verifyNoParametersFunctionCall(*$1);
		                                    }catch(parsingExceptions& e){
		                                        if(e.err_type == parsingExceptions::ERR_PROTOTYPE_MISMATCH)
                                                    throw parsingExceptions(e.err_type,
                                                    yylineno, $1->getName(), scopes::listToVector(scopesList->getFunction($1->getName()).inputTypes));
                                                else throw parsingExceptions(e.err_type,yylineno, $1->getName());
                                        }
		                                 $$ = new parsedExp((scopesList->getFunction($1->getName())).return_type);
		                                 delete $1;}
		;
//TODO Lior
ExpList:    Exp ExpList2 {  $$ = new parsedData(*$1,*$2) ;
		                                delete $1; delete $2;}

ExpList2 :                  { $$ = new parsedData(IS_CALL); }
         | COMMA ExpList    { $$ = $2;}
         ;

Type	:	INT              {$$ = new parsedData(Type(Type::INTEGER));}
		|	BYTE             {$$ = new parsedData(Type(Type::BYTE));}
		| 	BOOL             {$$ = new parsedData(Type(Type::BOOL));}
		;

Exp		:	LPAREN Exp RPAREN       {$$ = $2;}
		| 	ID LBRACK Exp RBRACK    {if (scopesList->containsIdName($1->getName())){
		                                if ($3->isInteger() && scopesList->getId($1->getName()).type.kind == Type::ARRAY){
		                                    $$ = new parsedExp(scopesList->getId($1->getName()).type.arrayType);
				                                delete $1; delete $3;
		                                }
		                                else
		                                    throw parsingExceptions(parsingExceptions::ERR_INVALID_ARRAY_SIZE,
		                                                            yylineno, $1->getName());  //TODO Exp not an inteeger!
                                      }
		                                else
		                                    throw parsingExceptions(parsingExceptions::ERR_UNDEF,
                                                  		            yylineno, $1->getName());      //TODO ID doesn't exist!
		                             }
		| 	Exp PLUS_MINUS Exp      {TRY_AND_CATCH($$ = new parsedExp(*$1,*$3, MATH_OP));
                                        delete $1; delete $3;
                                     }
		|	Exp MUL_DIV Exp         {TRY_AND_CATCH($$ = new parsedExp(*$1,*$3, MATH_OP));
                                         delete $1; delete $3;
                                     }
		| 	ID                      {if (scopesList->containsIdName($1->getName())){
		                                $$ = new parsedExp(scopesList->getId($1->getName()).type);
		                                delete $1;
		                                }
		                                else
		                                    throw parsingExceptions(parsingExceptions::ERR_UNDEF,
		                                                            yylineno, $1->getName());      //TODO

		                            }
		|	Call                    {$$ = $1;}

		|	NUM_T	                {$$ = $1;
		                            if(PRINT_DEBUG) {cout << "in exp-> NUM_T, NUM_T type = "; printID("",0,$1->single_var.type.toString());}}
		|	STRING                  {$$ = new parsedExp(Type(Type::STRING));} // return string type
		|	TRUE	                {$$ = new parsedExp(Type(Type::BOOL));} // return bool type
		|	FALSE	                {$$ = new parsedExp(Type(Type::BOOL));} // return bool type
		|	NOT Exp	                {TRY_AND_CATCH($$ = new parsedExp(*$2, BOOL_OP));
		 		                                delete $2;
		 		                     }
		|	Exp OR Exp              {TRY_AND_CATCH($$ = new parsedExp(*$1,*$3, BOOL_OP));
                                      	 delete $1; delete $3;
                                    }  // make sure Exp and Exp are of type bool
		|	Exp AND Exp	            {TRY_AND_CATCH($$ = new parsedExp(*$1,*$3, BOOL_OP));
                                    	 delete $1; delete $3;
                                    }     // make sure Exp and Exp are of type bool
		|	Exp EQ_OP Exp           {TRY_AND_CATCH($$ = new parsedExp(*$1,*$3, REL_OP));
                                     	 delete $1; delete $3;
                                     }     // For ambiguity reasons!!!!!!!!!
		|	Exp RELOP Exp           {TRY_AND_CATCH($$ = new parsedExp(*$1,*$3, REL_OP));
		                                 delete $1; delete $3;
		                             }
		;

LBRACE_t : LBRACE { scopesList->newRegularScope(false); }
         ;

RBRACE_t : RBRACE{ scopesList->removeScope(); }
         ;

%%

int main()
{
	// initSystem
	scopesList = new scopes();
	scopesList->scopesList.push_front( scope(0,false));
	Type tmp;
    scopesList->addInitialFunction( Type(tmp.VOID),string("print"), Type(tmp.STRING));
    scopesList->addInitialFunction( Type(tmp.VOID),string("printi"), Type(tmp.INTEGER));

    try{
	    yyparse();
	}catch(parsingExceptions& e){
	    scopesList->need_to_print = false;
	}
	catch(...){
	    scopesList->need_to_print = false;
        if(PRINT_DEBUG) cout << "Something wierd happened!!!" << endl;
	}
	if(scopesList->need_to_print){      //check valid main function in the scopelist
	    if(!scopesList->containsFunctionName("main")){
   	        scopesList->need_to_print = false;
            errorMainMissing();
    	}else{
    	    function main_func = scopesList->getFunction("main");
    	    if((main_func.return_type.kind != main_func.return_type.VOID ||
    	            !main_func.inputTypes.empty())){
                scopesList->need_to_print = false;
                errorMainMissing();
                if(PRINT_DEBUG) cout <<"in the if to check the main function" << endl;
            }
        }
    }
	delete scopesList;
}

void yyerror(const char * message)
{
    throw parsingExceptions(parsingExceptions::ERR_SYN, yylineno);
}
