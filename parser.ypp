%{
	#include "attributes.h"
	#include <iostream>
	#include <stdlib.h>

	using namespace std;
    extern int yylineno;
	extern int yylex();		// do they both need to be extern?
    void yyerror(const char * message);

    #define TRY_AND_CATCH(statement_to_try)                             \
        try{                                                            \
            (statement_to_try);                                         \
        }catch(parsingExceptions& e){                                   \
             throw parsingExceptions(e.err_type, yylineno, e.id);       \
        }

    #define EMIT_TEXT(string) scopes->buffer.emit(string);
    #define EMIT_DATA(string) scopes->buffer.emitData(string);

    #define MERGE(destination,l1,l2)      \
    l1.sort();                \
    l2.sort();                \
    destination = l1.merge(l2);

	scopes* scopesList;
%}

%token B
%token BYTE BOOL INT VOID TRUE FALSE RETURN WHILE BREAK SC COMMA ID NUM STRING
%right IF
%right ASSIGN
%left OR
%left AND
%left EQ_OP
%nonassoc RELOP
%left PLUS_MINUS
%left MUL_DIV
%right NOT
%left LPAREN
%left RPAREN
%nonassoc ELSE
%left LBRACE LBRACK RBRACE RBRACK

%%

Program	:	Funcs
    	;

Funcs :
		|	Function Funcs
		;
Function : FunctionDefinition LBRACE Statements RBRACE_t      {if(PRINT_DEBUG) cout << "parsed function" << endl;}
        ;


FunctionDefinition : RetType ID LPAREN Formals RPAREN {TRY_AND_CATCH(scopesList->addFunction(*$1,*$2,*$4));
                                                        TRY_AND_CATCH(scopesList->newFunctionScope(*$4));
                                                        delete $1; delete $2; delete $4;
                                                        if(PRINT_DEBUG) cout <<"added a new function " << $2->getName() << endl;}
                   ;

RetType : Type          {$$ = $1;}
		| VOID          {$$ = new parsedData(Type(Type::VOID));}
		;

Formals	:	                    {$$ = new parsedData();}  //Lior
		|	FormalsList         {$$ = $1;}
		;

Type_ID : Type ID       {if(scopesList->containsIdName($2->getName()))
                            throw parsingExceptions(parsingExceptions::ERR_DEF, yylineno, $2->getName());
                         $$ = new parsedData($1->single_var.type, $2->single_var.name);
                         delete $1; delete $2;


                         }    //Lior
		;

FormalsList :   FormalDecl {$$ = new parsedData(*$1, IS_CALL);
                            delete $1; }
            |   FormalDecl COMMA FormalsList {$$ = new parsedData(*$1,*$3) ;
                                              delete $1; delete $3;}
            ;

FormalDecl  :   Type_ID                     {TRY_AND_CATCH($$ = new parsedData(*$1));

                                             delete $1; }
            |   Type_ID LBRACK NUM_T RBRACK {TRY_AND_CATCH($$ = new parsedData(*$1, *$3, IS_ARRAY));
                                             delete $1; delete $3;}
            ;

NUM_T :	NUM NUM_T2  {try{$$ = new parsedData($2->single_var.type, $1->single_var.value);delete $1; delete $2;}
                     catch(parsingExceptions& e){throw parsingExceptions(e.err_type, yylineno, e.id);}}
		;

NUM_T2 :                 {$$ = new parsedData(Type(Type::INTEGER));}     //Lior
		| B              {$$ = new parsedData(Type(Type::BYTE));}    //Lior
		;


Statements  :   Statement
			|   Statement Statements
			;

Statement : 	LBRACE_t Statements RBRACE_t
			|	Type_ID SC          {TRY_AND_CATCH(scopesList->addIdNotArray(*$1));

			                         delete $1;}
			|	Type_ID ASSIGN Exp SC           {TRY_AND_CATCH(scopesList->addIdNotArray(*$1));
			                                     TRY_AND_CATCH(scopesList->verifyAssign(*$1,*$3));
						                         delete $1; delete $3; }
			|	Type_ID LBRACK NUM_T RBRACK SC      {TRY_AND_CATCH(scopesList->addIdArray(*$1,*$1,*$3));
			                                          delete $1; delete $3; }
			|	ID ASSIGN Exp SC        {if (scopesList->containsIdName($1->getName())){
                                                  TRY_AND_CATCH(scopesList->verifyAssign(*$1,*$3));
                                                  delete $1; delete $3;
                                            }
                                         	else
                                         	   throw parsingExceptions(parsingExceptions::ERR_UNDEF,
                                         	                          yylineno, $1->getName() );  //TODO
                                         }
			|	ID LBRACK Exp RBRACK ASSIGN Exp SC  {if (scopesList->containsIdName($1->getName())){
                                                         TRY_AND_CATCH(scopesList->verifyAssignToArray(*$1,*$3,*$6));
                                                        delete $1; delete $3; delete $6;
                                                      } else
                                                         throw parsingExceptions(parsingExceptions::ERR_UNDEF,
                                                                            yylineno, $1->getName());  //TODO
                                                    }
			|	Call SC             {delete $1;}
			|	RETURN SC           {TRY_AND_CATCH(scopesList->verifyReturnTypeVoid());}
			|	RETURN Exp SC       {TRY_AND_CATCH(scopesList->verifyReturnType(*$2));
					                 delete $2;}

            | If_Begin If_Continue
           	|	While_Statement
			|	BREAK SC            {TRY_AND_CATCH(scopesList->verifyBreakBlock());}
			;

If_Begin    :  IF LPAREN Exp {if(!$3->isBool()) throw parsingExceptions(parsingExceptions::ERR_MISMATCH,yylineno); delete $3;}
            ;

If_Continue :   RPAREN Open_Scope Statement {scopesList->removeScope();}
            |   RPAREN Open_Scope Statement ELSE CloseScope Open_Scope Statement {scopesList->removeScope();}
            ;



Open_Scope : { scopesList->newRegularScope(false);}
           ;

CloseScope : { scopesList->removeScope(); }
           ;

While_Statement : While_Open Statement {scopesList->removeScope();}
            ;

While_Open : WHILE LPAREN Exp RPAREN {TRY_AND_CATCH(scopesList->verifyExpIsBool(*$3));
                                      TRY_AND_CATCH(scopesList->newRegularScope(true));
                                      delete $3;}
        ;

//end of need to fix if

//TODO Inbar call returns type
Call	:	ID LPAREN ExpList RPAREN    {try {scopesList->verifyFunctionCall(*$1,*$3);}
                                            catch(parsingExceptions& e){
                                            if(e.err_type == parsingExceptions::ERR_PROTOTYPE_MISMATCH)
                                                throw parsingExceptions(e.err_type,
                                                yylineno, $1->getName(),scopes::listToVector(scopesList->getFunction($1->getName()).inputTypes));
                                            else
                                                throw parsingExceptions(e.err_type,
                                                yylineno, $1->getName());
                                            }
                                         $$ = new parsedExp((scopesList->getFunction($1->getName())).return_type);
                                         delete $1; delete $3;}
		|	ID LPAREN RPAREN            {try {scopesList->verifyNoParametersFunctionCall(*$1);
		                                    }catch(parsingExceptions& e){
		                                        if(e.err_type == parsingExceptions::ERR_PROTOTYPE_MISMATCH)
                                                    throw parsingExceptions(e.err_type,
                                                    yylineno, $1->getName(), scopes::listToVector(scopesList->getFunction($1->getName()).inputTypes));
                                                else throw parsingExceptions(e.err_type,yylineno, $1->getName());
                                        }
		                                 $$ = new parsedExp((scopesList->getFunction($1->getName())).return_type);
		                                 delete $1;}
		;
//TODO Lior
ExpList:    Exp ExpList2 {  $$ = new parsedData(*$1,*$2) ;
		                                delete $1; delete $2;}

ExpList2 :                  { $$ = new parsedData(IS_CALL); }
         | COMMA ExpList    { $$ = $2;}
         ;

Type	:	INT              {$$ = new parsedData(Type(Type::INTEGER));}
		|	BYTE             {$$ = new parsedData(Type(Type::BYTE));}
		| 	BOOL             {$$ = new parsedData(Type(Type::BOOL));}
		;

Exp		:	LPAREN Exp RPAREN       {$$ = $2;}
		| 	ID LBRACK Exp RBRACK    {if (!scopesList->containsIdName($1->getName()))  //ID doesn't exist
                                        throw parsingExceptions(parsingExceptions::ERR_UNDEF,yylineno, $1->getName());
                                     if(!(scopesList->getId($1->getName()).type.kind == Type::ARRAY)) //ID is not an array
                                        throw parsingExceptions(parsingExceptions::ERR_MISMATCH,yylineno);
                                     if (!($3->isInteger())) // Exp is not a numeric type
                                        throw parsingExceptions(parsingExceptions::ERR_INVALID_ARRAY_SIZE, yylineno, $1->getName());

                                     $$ = new parsedExp(scopesList->getId($1->getName()).type.arrayType);

                                     $$->reg = regAlloc();
                                     $$->regType = value;

                                     // runtime check that Exp value is smaller than array size
                                     string s1 = "lw ";



                                     delete $1; delete $3;
		                            }
		| 	Exp PLUS_MINUS Exp      {TRY_AND_CATCH($$ = new parsedExp(*$1,*$3, MATH_OP));
		                             $$->reg = regAlloc();
                                     $$->regType = value;

                                     string s1 = codeGenerator::arithmeticOpToString($2->pd_op);
                                     string s2 = $$->reg.toString();  //destination
                                     string s3 = ", ";
                                     string s4 = $3->reg.toString();
                                     string s5 = ", ";
                                     string s6 = $1->reg.toString();

                                     EMIT_TEXT(s1 + s2 + s3 + s4 + s5 + s6);
                                     if($$->single_var.type.kind == Type::BYTE){
                                        EMIT_TEXT(codeGenerator::byteArithmeticMasking($$->reg));
                                     }
                                     delete $1; delete $3;
                                     }
		|	Exp MUL_DIV Exp         {TRY_AND_CATCH($$ = new parsedExp(*$1,*$3, MATH_OP));
		                             $$->reg = regAlloc();
		                             $$->regType = value;

		                             string s1 = codeGenerator::arithmeticOpToString($2->pd_op);

		                             if(s1 == "div "){
		                                EMIT_TEXT(codeGenerator::divisionByZeroCheck($3->reg));
		                             }

		                             string s2 = $$->reg.toString();  //destination
		                             string s3 = ", ";
                                     string s4 = $3->reg.toString();
                                     string s5 = ", ";
                                     string s6 = $1->reg.toString();

                                     EMIT_TEXT(s1 + s2 + s3 + s4 + s5 + s6);
                                     if($$->single_var.type.kind == Type::BYTE){
                                        EMIT_TEXT(codeGenerator::byteArithmeticMasking($$->reg));
                                     }
                                     delete $1; delete $3;
                                     }
		| 	ID                      {if (!scopesList->containsIdName($1->getName()))
		                                throw parsingExceptions(parsingExceptions::ERR_UNDEF,yylineno, $1->getName());

		                             $$ = new parsedExp(scopesList->getId($1->getName()).type);
		                             $$->reg = regAlloc();

                                     string s1 = "move ";
                                     string s2 = $$->reg.toString();
                                     string s3 = ", ";
		                             string s4;

		                             if($$->kind == parsedData::DK_ARRAY){
		                                $$->regType = reference;
		                                s4 =  codeGenerator::idLocation($1->getName()); // debug : make sure there are no too much/too little dereferences
		                             }
		                             else{
                                        $$->regType = value;

                                        string temp1 = "(", temp2 = ")";
                                        s4 =  temp1 + codeGenerator::idLocation($1->getName()) + temp2;
		                             }

		                             EMIT_TEXT(s1 + s2 + s3 + s4);

		                             delete $1;
		                            }

		|	Call                    {$$ = new parsedExp($1);
                                     $$->reg =  regAlloc();
                                     $$->regType = value;
                                     // calling the function code
                                     string s1 = "move $r0, ";
                                     string s2 = $$->reg.toString;
                                     EMIT_TEXT(s1 + s2);
                                    }

        |	NUM_T	                {$$ = new parsedExp($1);
                                    $$->reg =  regAlloc();
                                    $$->regType = value;
                                    string s1 = "li " // load immediate
                                    string s2 = $$->reg.toString();
                                    string s3 = ", ";
                                    string s4 = numToString($$.singleVar.value);
                                    EMIT_TEXT(s1 + s2 + s3 + s4);
                                    }

        |	STRING                  {$$ = new parsedExp(Type(Type::STRING));    // return string type
                                     $$->reg =  regAlloc();
                                     $$->regType = reference;

                                     // create string in .data segment
                                     string s1 = genDataLabel();
                                     string s2 = ".asciiz \"";
                                     string s3 = $1->single_var.name;
                                     string s4 = "\"";
                                     EMIT_DATA(s1 + s2 + s3 + s4);

                                     // generate code " la  $$->reg, <string location label>"
                                     string s12 = "la "; // load address, need to verify it works with labels
                                     string s22 = $$->reg.toString();
                                     string s32 = ", ";
                                     string s42 = s1;
                                     EMIT_TEXT(s12 + s22 + s32 + s42);

                                    }
        |	TRUE	                {$$ = new parsedExp(Type(Type::BOOL)); // return bool type
                                     $$->trueList.pushFront(EMIT_TEXT("j "));
                                    }

		|	FALSE	                {$$ = new parsedExp(Type(Type::BOOL)); // return bool type
		                             $$->falseList.pushFront(EMIT_TEXT("j "));
                                    }

		|	NOT Exp	                {TRY_AND_CATCH($$ = new parsedExp(*$2, BOOL_OP));
		 		                     $$->trueList = $2->falseList;
		 		                     $$->falseList = $2->trueList;
		 		                     delete $2;
		 		                    }
		|	Exp OR Exp              {TRY_AND_CATCH($$ = new parsedExp(*$1,*$3, BOOL_OP));
                                        if(PRINT_DEBUG)
        		                            cout << "parsed exp OR exp: "
        		                            << $1->getName() << " " << $3->getName()
        		                            << endl;

                                     buffer.bpatch($1->falseList,$3->beginLabel);
                                     $$->falseList = $3->falseList;
                                     MERGE($$->trueList,$3->trueList,$1->trueList);

        		                     delete $1; delete $3;
                                    }  // make sure Exp and Exp are of type bool
		|	Exp AND Exp	            {TRY_AND_CATCH($$ = new parsedExp(*$1,*$3, BOOL_OP));
                                        if(PRINT_DEBUG)
        		                            cout << "parsed exp AND exp: "
        		                            << $1->getName() << " " << $3->getName()
        		                            << endl;

        		                     buffer.bpatch($1->trueList,$3->beginLabel);
                                    $$->trueList = $3->trueList;
                                    MERGE($$->falseList,$3->falseList,$1->falseList);

        		                     delete $1; delete $3;
                                    }     // make sure Exp and Exp are of type bool
		|	Exp EQ_OP Exp           {TRY_AND_CATCH($$ = new parsedExp(*$1,*$3, REL_OP));
		                                if(PRINT_DEBUG)
		                                    cout << "parsed exp EQ_OP exp: "
		                                     << $1->getName() << " " << $3->getName()
		                                     << endl;

                                     string s1 = codeGenerator::opToBranchString($2->pd_op); // branch type
                                     string s2 = $1->reg.toString();
                                     string s3 = ", ";
                                     string s4 = $3->reg.toString();
                                     string s5 = ", ";
                                     $$->trueList.pushFront(EMIT_TEXT(s1 + s2 + s3 + s4 + s5));
                                     $$->falseList.pushFront(EMIT_TEXT("j "));

                                     delete $1; delete $3;
                                     }
		|	Exp RELOP Exp           {TRY_AND_CATCH($$ = new parsedExp(*$1,*$3, REL_OP));
		                                if(PRINT_DEBUG)
        		                             cout << "parsed exp RELOP exp: "
        		                             << $1->getName() << " " << $3->getName()
        		                             << endl;

		                             string s1 = codeGenerator::opToBranchString($2->pd_op); // branch type
                                     string s2 = $1->reg.toString();
                                     string s3 = ", ";
                                     string s4 = $3->reg.toString();
                                     string s5 = ", ";
                                     $$->trueList.pushFront(EMIT_TEXT(s1 + s2 + s3 + s4 + s5));
                                     $$->falseList.pushFront(EMIT_TEXT("j "));

		                             delete $1; delete $3;
		                            }
		;


LBRACE_t : LBRACE { scopesList->newRegularScope(false); }
         ;

RBRACE_t : RBRACE{ scopesList->removeScope(); }
         ;

%%

int main()
{
	// initSystem
	scopesList = new scopes();
	scopesList->scopesList.push_front( scope(0,false));
	Type tmp;
    scopesList->addInitialFunction( Type(tmp.VOID),string("print"), Type(tmp.STRING));
    scopesList->addInitialFunction( Type(tmp.VOID),string("printi"), Type(tmp.INTEGER));

    try{
	    yyparse();
	}catch(parsingExceptions& e){
	    scopesList->need_to_print = false;
	}
	catch(...){
	    scopesList->need_to_print = false;
        if(PRINT_DEBUG) cout << "Something wierd happened!!!" << endl;
	}
	if(scopesList->need_to_print){      //check valid main function in the scopelist
	    if(!scopesList->containsFunctionName("main")){
   	        scopesList->need_to_print = false;
            errorMainMissing();
    	}else{
    	    function main_func = scopesList->getFunction("main");
    	    if((main_func.return_type.kind != main_func.return_type.VOID ||
    	            !main_func.inputTypes.empty())){
                scopesList->need_to_print = false;
                errorMainMissing();
                if(PRINT_DEBUG) cout <<"in the if to check the main function" << endl;
            }
        }
    }
	delete scopesList;
}

void yyerror(const char * message)
{
    throw parsingExceptions(parsingExceptions::ERR_SYN, yylineno);
}