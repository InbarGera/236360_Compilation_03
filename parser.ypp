%{
	#include "attributes.h"
	#include <iostream>
	#include <stdlib.h>

	using namespace std;

	extern int yylex();		// do they both need to be extern?
	int yyerror(char * message);

	scopes* scopesList;
%}


%token B
%token BYTE BOOL INT VOID TRUE FALSE RETURN IF ELSE WHILE BREAK SC COMMA ID NUM STRING
%right ASSIGN
%nonassoc RELOP
%left EQ_OP
%left OR
%left AND
%left PLUS_MINUS
%left MUL_DIV
%left NOT
%left LBRACE LBRACK LPAREN RBRACE RBRACK RPAREN

%%


Program	:	Funcs
    	;

Funcs 	:	
		|	Function Funcs
		;

Function    : FunctionOpen FunctionClose
        ;

FunctionOpen    :   RetType ID LPAREN Formals RPAREN LBRACE
{
    addFunction($1,$2,$4);
    newFunctionScope($2,$4);
    newRegularScope(false); // true is received only in case of a while scope
}
        ;

FunctionClose   :   Statements RBRACE
{
    closeScope();
    closeScope();
}
        ;

RetType : Type          {$$ = $1;}
		| VOID          {$$ = new parsedType(VOID);}
		;
		
Formals	:	
		|	FormalsList
		;
		
Type_ID : Type ID       {$$ = new parsedTpID($1, $2);}
		;
		
FormalsList	:	FormalDecl FormalsList2
			;

FormalsList2	:
				|	COMMA FormalsList
				;

FormalDecl	:	Type_ID	FormalDecl2
			;

FormalDecl2	:	
			| 	LBRACK NUM_T RBRACK
			;

NUM_T	:	NUM NUM_T2  {$$ = new parsedNum($1, $2);	}
		;
		
NUM_T2	:               {$$ = new parsedNum();}
		| B             {$$ = new parsedNum(BYTE);}
		;

Statements : Statement
			| Statement Statements
			;

Statement	:	LBRACE Statements RBRACE
			|	Type_ID SC
			|	Type_ID ASSIGN Exp SC
			|	Type_ID LBRACK NUM_T RBRACK SC
			|	ID ASSIGN Exp SC
			|	ID LBRACK Exp RBRACK ASSIGN Exp SC
			|	Call SC
			|	RETURN SC
			|	RETURN Exp SC
			|	IF_STATE
			|	WHILE LPAREN Exp RPAREN Statement
			|	BREAK SC
			|   SC
			;
			
IF_STATE	:	IF LPAREN Exp RPAREN Statement IF_STATE_ELSE
			;

IF_STATE_ELSE	:	
				|	ELSE Statement
				;

Call	:	ID LPAREN ExpList RPAREN    {$$ = new parsedCall($1,$3);}
		|	ID LPAREN RPAREN            {$$ = new parsedCall($1);}
		;

ExpList	:	Exp                     {$$ = new parsedExpList($1)}
		|	Exp COMMA ExpList       {$$ = new parsedExpList($1, $2);}
		;
		
Type	:	INT              {$$ = new parsedType(INT);} // to return new type with appropriate type
		|	BYTE             {$$ = new parsedType(BYTE);}
		| 	BOOL             {$$ = new parsedType(BOOL);}
		;
		
Exp		:	LPAREN Exp RPAREN       {$$ = $2;} 
		| 	ID LBRACK Exp RBRACK    {$$ = new parsedExp($1,$3);} // make sure Id ia an array, Exp is int/byte
		| 	Exp PLUS_MINUS Exp      {$$ = new parsedExp($1,parsedOp(yytext),$3);}
		|	Exp MUL_DIV Exp         {$$ = new parsedExp($1,parsedOp(yytext),$3);}
		| 	ID                      {$$ = $1;}
		|	Call
		|	NUM_T	                {$$ = $1;}
		|	STRING                  {$$ = new parsedExp($1);} // return string type
		|	TRUE	                {$$ = new parsedExp(true);} // return bool type
		|	FALSE	                {$$ = new parsedExp(false);} // return bool type
		|	NOT Exp	                {$$ = !$1; }  // return bool type
		|	Exp OR Exp              {$$ = new parsedExp($1,parsedOp("||"),$3);}
		|	Exp AND Exp	            {$$ = new parsedExp($1,parsedOp("&&"),$3);}
		|	Exp EQ_OP Exp           {$$ = new parsedExp($1,$parsedOp(yytext)2,$3);}
		|	Exp RELOP Exp           {$$ = new parsedExp($1,parsedOp(yytext),$3);}
		;

%%

int main()
{
	// initSystem
	scopesList = new scopes();
	//to do
	yyparse();

}

int yyerror(char * message)
{
	cout<<"Parse error: "<<message<<endl;
	exit(0);
}
