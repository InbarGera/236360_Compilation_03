%{
	#include "attributes.h"
	#include <iostream>
	#include <stdlib.h>

	using namespace std;
    extern int yylineno;
	extern int yylex();		// do they both need to be extern?
    int yyerror(char * message);
	scopes* scopesList;
%}

%token B
%token BYTE BOOL INT VOID TRUE FALSE RETURN WHILE BREAK SC COMMA ID NUM STRING
%right IF
%nonassoc RPAREN
%nonassoc ELSE
%right ASSIGN
%nonassoc RELOP
%left EQ_OP
%left OR
%left AND
%left PLUS_MINUS
%left MUL_DIV
%left NOT
%left LBRACE LBRACK LPAREN RBRACE RBRACK

%%

Program	:	Funcs
    	;

Funcs :
		|	Function Funcs
		;
Function : FunctionDefinition LBRACE_t Statements RBRACE_t      {cout << "parsed function" << endl;}
        ;


FunctionDefinition : RetType ID LPAREN Formals RPAREN {try{
                                                        scopesList->addFunction(*$1,*$2,*$4);
                                                        scopesList->newFunctionScope(*$2);
                                                        }catch(parsingExceptions& e){
                                                            throw parsingExceptions(e.err_type, yylineno, $1->getName());
                                                        }
                                                        delete $1; delete $2; delete $4;
                                                        cout <<"added a new function " << $2->getName() << endl;}
                   ;

RetType : Type          {$$ = $1;
                        /*delete $1;*/}      //TODO is it ok????????????????  Lior
		| VOID          {	Type tmp; $$ = new parsedData( Type(tmp.VOID));}    //Lior
		;

Formals	:	                    {$$ = new parsedData();}  //Lior
		|	FormalsList         {$$ = $1;
		                        /*delete $1;*/}      //TODO is it ok????????????????  Lior
		;

Type_ID : Type ID       {if(scopesList->containsIdName($2->getName()))
                            throw parsingExceptions(parsingExceptions::ERR_DEF, yylineno, $2->getName());
                            $$ = new parsedData(*$1, *$2);
                            delete $1; delete $2;}    //Lior
		;

FormalsList :   FormalDecl {$$ = new parsedData(*$1, IS_CALL);
                            delete $1; }
            |   FormalDecl COMMA FormalsList {$$ = new parsedData(*$1,*$3) ;
                                              delete $1; delete $3;}
            ;

FormalDecl  :   Type_ID                     {try{
                                                $$ = new parsedData(*$1);
                                             }
                                             catch(parsingExceptions& e){
                                                  throw parsingExceptions(e.err_type, yylineno, $1->getName());
                                             }
                                             delete $1; }
            |   Type_ID LBRACK NUM_T RBRACK {try{
                                                $$ = new parsedData(*$1, *$3, IS_ARRAY);
                                             }catch(parsingExceptions& e){
                                                throw parsingExceptions(e.err_type, yylineno, $1->getName());
                                             }
                                             delete $1; delete $3;}
            ;

NUM_T :	NUM NUM_T2  {$$ = new parsedData(*$1, *$2); /*TODO add type/byte check */
                        delete $1; delete $2;}
		;

NUM_T2 :                 {$$ = new parsedData(Type::INTEGER);}     //Lior
		| B              {$$ = new parsedData(Type::BYTE);}    //Lior
		;


Statements  :   Statement
			|   Statement Statements
			;

Statement : 	LBRACE_t Statements RBRACE_t
			|	Type_ID SC          {try{
			                            scopesList->addIdNotArray(*$1);
			                         }catch(parsingExceptions& e){
                                         throw parsingExceptions(e.err_type, yylineno, $1->getName());
                                     }
			                         delete $1;}
			|	Type_ID ASSIGN Exp SC           {try{
			                                        scopesList->addIdNotArray(*$1);
			                                        scopesList->verifyAssign(*$1,*$3);
						                         }catch(parsingExceptions& e){
                                                    throw parsingExceptions(e.err_type, yylineno, $1->getName());
                                                 }
						                            delete $1; delete $3; }
			|	Type_ID LBRACK NUM_T RBRACK SC      {try{
			                                            scopesList->addIdArray(*$1,*$1,*$3);
			                                          }
			                                          catch(parsingExceptions& e){
                                                          throw parsingExceptions(e.err_type, yylineno, $1->getName());
                                                      }
			                                         delete $1; delete $3; }
			|	ID ASSIGN Exp SC        {if (scopesList->containsIdName($1->getName())){
                                                  try{
                                             		  scopesList->verifyAssign(*$1,*$3);
                                                  }
                                                  catch(parsingExceptions& e){
                                                    throw parsingExceptions(e.err_type, yylineno, $1->getName());
                                                  }
                                                  delete $1; delete $3;
                                            }
                                         	else
                                         	   throw parsingExceptions(parsingExceptions::ERR_UNDEF,
                                         	                          yylineno, $1->getName() );  //TODO
                                         }
			|	ID LBRACK Exp RBRACK ASSIGN Exp SC  {if (scopesList->containsIdName($1->getName())){
                                                         try{
                                                            scopesList->verifyAssignToArray(*$1,*$3,*$6);
                                                         }
                                                         catch(parsingExceptions& e){
                                                            throw parsingExceptions(e.err_type, yylineno, $1->getName());
                                                         }

                                                         delete $1; delete $3; delete $6;
                                                      } else
                                                         throw parsingExceptions(parsingExceptions::ERR_UNDEF,
                                                                            yylineno, $1->getName());  //TODO
                                                    }
			|	Call SC             {delete $1;}// done
			|	RETURN SC           {try{
			                            scopesList->verifyReturnTypeVoid();}
			                            catch(parsingExceptions& e){
                                           throw parsingExceptions(e.err_type, yylineno);
                                        }
			                        }
			|	RETURN Exp SC       {   try{
			                                scopesList->verifyReturnType(*$2);
					                        }catch(parsingExceptions& e){
					                            throw parsingExceptions(e.err_type, yylineno);
					                        }
					                     delete $2;}
			|   IF LPAREN Exp RPAREN Open_Scope Statement
			                            { if(!$3->isBool())
			                                    throw parsingExceptions(parsingExceptions::ERR_MISMATCH,
			                                    yylineno);
			                             scopesList->removeScope();
			                              delete $3;}
			|   IF LPAREN Exp RPAREN Open_Scope Statement ELSE CloseScope Open_Scope Statement
			                            { if(!$3->isBool())
                                          	throw parsingExceptions(parsingExceptions::ERR_MISMATCH,
                                          	   yylineno);
                                            scopesList->removeScope();
			                             delete $3;}
			|	While_Statement
			|	BREAK SC            {scopesList->verifyBreakBlock();}
			;

Open_Scope : { scopesList->newRegularScope(false);}
           ;

CloseScope : { scopesList->removeScope(); }
           ;

While_Statement : While_Open Statement {scopesList->removeScope();}
            ;

While_Open : WHILE LPAREN Exp RPAREN {scopesList->verifyExpIsBool(*$3);
                                        scopesList->newRegularScope(true);
                                        delete $3;}    // done
        ;

//end of need to fix if

//TODO Inbar call returns type
Call	:	ID LPAREN ExpList RPAREN    {try {scopesList->verifyFunctionCall(*$1,*$3);}
                                            catch(parsingExceptions& e){
                                            throw parsingExceptions(e.err_type,
                                                    yylineno, $1->getName(), $3->getArgsTypes());
                                            }
                                         $$ = new parsedExp((scopesList->getFunction($1->getName())).return_type);
                                         delete $1; delete $3;}
		|	ID LPAREN RPAREN            {try {scopesList->verifyNoParametersFunctionCall(*$1);
		                                    }catch(parsingExceptions& e){
                                              throw parsingExceptions(e.err_type,
                                                yylineno, $1->getName(), vector<string>());
                                        }
		                                 $$ = new parsedExp((scopesList->getFunction($1->getName())).return_type);
		                                 delete $1;}
		;
//TODO Lior
ExpList:    Exp ExpList2 {  $$ = new parsedData(*$1,*$2) ;
		                                delete $1; delete $2;}

ExpList2 :                  { $$ = new parsedData(); }
         | COMMA ExpList    { $$ = new parsedData(*$2, IS_CALL);
         		                                delete $2;}
         ;

Type	:	INT              {$$ = new parsedData(parsedData(Type(Type::INTEGER)));} // to return new type with appropriate type
		|	BYTE             {$$ = new parsedData(parsedData(Type(Type::BYTE)));}
		| 	BOOL             {$$ = new parsedData( parsedData(Type(Type::BOOL)));}
		;

Exp		:	LPAREN Exp RPAREN       {if(!($2->isInteger()))
                                            throw parsingExceptions(parsingExceptions::ERR_INVALID_ARRAY_SIZE,
                                            yylineno);
                                       $$ = $2;
                                    /*delete $2;*/}      //TODO is it ok????????????????  Lior
		| 	ID LBRACK Exp RBRACK    {if (scopesList->containsIdName($1->getName())){
		                                if ($3->isInteger()){
		                                    $$ = new parsedExp(scopesList->getId($1->getName()).type);
				                                delete $1; delete $3;
		                                }
		                                else
		                                    throw parsingExceptions(parsingExceptions::ERR_INVALID_ARRAY_SIZE,
		                                                            yylineno, $1->getName());  //TODO Exp not an inteeger!
                                      }
		                                else
		                                    throw parsingExceptions(parsingExceptions::ERR_UNDEF,
                                                  		            yylineno, $1->getName());      //TODO ID doesn't exist!
		                             }
		| 	Exp PLUS_MINUS Exp      {try{$$ = new parsedExp(*$1,*$3, MATH_OP);
                                        delete $1; delete $3;
                                        }       // make sure Exp and Exp are COMPATIABLE types
                                    catch(parsingExceptions& e){
                                       	throw parsingExceptions(e.err_type, yylineno);
                                      	}
                                    }
		|	Exp MUL_DIV Exp         {try{$$ = new parsedExp(*$1,*$3, MATH_OP);
                                         delete $1; delete $3;
                                         }       // make sure Exp and Exp are COMPATIABLE types
                                     catch(parsingExceptions& e){
                                          	throw parsingExceptions(e.err_type, yylineno);
                                          	}
                                    }
		| 	ID                      {if (scopesList->containsIdName($1->getName())){
		                                $$ = new parsedExp(scopesList->getId($1->getName()).type);
		                                delete $1;
		                                }
		                                else
		                                    throw;      //TODO

		                            }
		|	Call                    {$$ = $1;
    		                        /*delete $1;*/}      //TODO is it ok????????????????  Lior

		|	NUM_T	                {$$ = new parsedExp(*$1);
		                                        delete $1;  }
		|	STRING                  {	Type tmp;
                                        $$ = new parsedExp(Type(tmp.STRING));
                                        delete $1;} // return string type
		|	TRUE	                {	Type tmp; $$ = new parsedExp(Type(tmp.BOOL));} // return bool type
		|	FALSE	                {	Type tmp; $$ = new parsedExp(Type(tmp.BOOL));} // return bool type
		|	NOT Exp	                {try{$$ = new parsedExp(*$2, BOOL_OP);
		 		                                delete $2;
		 		                          }  // make sure Exp type is bool
		 		                     catch(parsingExceptions& e){
                                       	throw parsingExceptions(e.err_type, yylineno);
		 		                            }
		 		                     }
		|	Exp OR Exp              {try{$$ = new parsedExp(*$1,*$3, BOOL_OP);
                                      	 delete $1; delete $3;
                                      	}       // make sure Exp and Exp are COMPATIABLE types
                                    catch(parsingExceptions& e){
                                       	throw parsingExceptions(e.err_type, yylineno);
                                       	}
                                    }  // make sure Exp and Exp are of type bool
		|	Exp AND Exp	            {try{$$ = new parsedExp(*$1,*$3, BOOL_OP);
                                    	 delete $1; delete $3;
                                    	}       // make sure Exp and Exp are COMPATIABLE types
                                    catch(parsingExceptions& e){
                                    	throw parsingExceptions(e.err_type, yylineno);
                                    	}
                                   }     // make sure Exp and Exp are of type bool
		|	Exp EQ_OP Exp           {try{$$ = new parsedExp(*$1,*$3, REL_OP);
                                     	 delete $1; delete $3;
                                     	}       // make sure Exp and Exp are COMPATIABLE types
                                     catch(parsingExceptions& e){
                                     	throw parsingExceptions(e.err_type, yylineno);
                                     	}
                                     }     // For ambiguity reasons!!!!!!!!!
		|	Exp RELOP Exp           {try{
		                                 $$ = new parsedExp(*$1,*$3, REL_OP);
		                                 delete $1; delete $3;
		                                 }       // make sure Exp and Exp are COMPATIABLE types
		                             catch(parsingExceptions& e){
		                                    throw parsingExceptions(e.err_type, yylineno);
		                                 }
		                             }
		;

LBRACE_t : LBRACE { scopesList->newRegularScope(false); }
         ;

RBRACE_t : RBRACE{ scopesList->removeScope(); }
         ;

%%

int main()
{
	// initSystem
	scopesList = new scopes();
	scopesList->scopesList.push_front( scope(0,false));
	Type tmp;
    scopesList->addInitialFunction( Type(tmp.VOID),string("print"), Type(tmp.STRING));
    scopesList->addInitialFunction( Type(tmp.VOID),string("printi"), Type(tmp.INTEGER));

    try{
	    yyparse();
	}catch(parsingExceptions& e){
	    scopesList->need_to_print = false;
	    cout << "\n\n caught an exception while parsing!" << endl;
	    e.printErrMsg();
	    cout << "printed the error\n\n" << endl;
	}
	catch(...){
	    scopesList->need_to_print = false;
        cout << "Something wierd happened!!!" << endl;
	}
	if(!scopesList->containsFunctionName("main")){
	    if(scopesList->need_to_print){
	        scopesList->need_to_print = false;
            errorMainMissing();
	    }
	}
	delete scopesList;
}

int yyerror(char * message)
{
    throw parsingExceptions(parsingExceptions::ERR_SYN, yylineno);
}